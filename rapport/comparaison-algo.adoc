:toc:
:toc-placement!:
:toc-title: Table des matières
:sectnums:

image::/rapport/images/logo_transparent.png[]

= SAE 2.02 - Comparaison d'approches algorithmiques

_Réalisé par FERNANDEZ Mickael (4A)_

toc::[]

== Objectif

Parmi l'ensemble des solutions algorithmiques proposées, il est nécessaire de les explorer en ayant une approche s'intéressant à l'implémentation bas niveau (structures de données, etc.) ainsi qu'à haut niveau (précision des résultats, etc.)

[NOTE]
[.text-justify]
Les solutions algorithmiques sont des fichiers de divers langages (C, Python, Java) dont le but était de seulement retirer les espaces individuels, qu'importe de l'emplacement de ceux-ci.

*NOTATION*

En voici la grille de notation :

|===
|*Cas*|*Points*
|Ne compile/s'exécute pas|0
|Ne passe pas les tests fournis ou a rate certains cas|1
|Meilleur algo de la catégorie|5
|2nd algo|4
|3e algo|3
|4e algo|2
|===
En cas d'ex-aequo, même note. (5/5/3/2 par exemple).

== Catégorie "Sobriété"

=== Sobriété n°57 (langage C)

==== Prérequis
Deux prérequis sont alors nécessaires à l'analyse du fichier ``sobriete-57.c`` :

____
● Un IDE collaboratif (ici, repl.it était utilisé pour la sobriété) ; +
● Un IDE (ici, CodeBlocks était utilisé pour le temps d'exécution).
____

==== Reproductibilité et références
[.text-justify]
*Repl.it :*

[.text-justify]
Repl.it ne nécessite pas de configuration particulière pour pouvoir compiler et exécuter un programme, quel que soit le langage utilisé. + 
Pour paramétrer votre fichier ``sobriete-57.c``, il suffit de :

____
● Créer un compte repl.it ou l'associer avec un compte Google, GitHub, etc. +
● Créer un "Repl" dont votre template sera en C, avec un titre au choix. +
● Déposer votre code en C et exécutez-le.
____

[.text-justify]
*CodeBlocks :*

[.text-justify]
CodeBlocks ne nécessite pas de configuration particulière pour pouvoir compiler et exécuter un programme, ici en C. L'avantage de son utilisation est que le temps d'exécution est automatiquement calculé. Ainsi, pour paramétrer votre fichier ``sobriete-57.c``, il est d'abord nécessaire de l'installer. Pour toutes ces étapes, il suffit de :

____
● Se rendre sur le site de https://www.codeblocks.org/downloads/[__Code::Blocks__] et aller dans la section "Downloads" puis "Download the binary release" ; +
● Paramétrez alors votre logiciel CodeBlocks selon vos préférences ; +
● Une fois CodeBlocks d'ouvert, sélectionnez "File" > "Open..." et enfin, trouvez votre fichier ; +
● Exécutez votre code.
____

*Autres :*

Enfin, il en va également de même pour connaître le nombre d'itérations de votre programme, autrement dit, combien de fois est réalisée votre condition en fonction de la chaîne de caractère renseignée. +

Pour ce faire, veuillez à déclarer une variable de type entier au début de votre fonction puis, incrémentez cette valeur *au moment où* l'analyse de votre chaîne de caractère avance également et enfin, veuillez retourner votre résultat pour connaître le nombre de fois où vos conditions ont été exécutée :

[source, c]
----
//Déclarations de variables de test
  int nbIterations = 0;
  
  [...]
  
//Dans les conditions :
  nbIterations++;
  
  [...]
  
//Affichage des tests
  printf("\nNombre d'itérations : %d", nbIterations);
----

==== Analyse
[.text-justify]

===== Lisibilité du code
[.text-justify]

===== Qualité du code
[.text-justify]
De ce qui peut être constaté, quelques erreurs mineurs sont à constater sur cette solution algorithmique par *Codacy* : +

____
● Ne gère pas les chaînes qui ne sont pas terminées par \0 ; si on lui en donne un, il peut effectuer une surlecture (cela pourrait provoquer un plantage s'il n'est pas protégé) ; +
● La condition 'chaine[i]==' '' est _visiblement_ toujours vraie ; +
____

D'après *Codacy*, le fichier ``sobriete-57.c`` est noté "B".

image::/rapport/images/sobriete-57.PNG[]

===== Sobriété numérique
[.text-justify]

===== Efficacité et temps d'exécution
[.text-justify]
Pour alors évaluer l'efficacité et le temps d'exécution de la solution algorithmique, un ensemble de tests est alors réalisé. +
Pour ces tests, j'ai procédé à prendre une chaîne de caractère déjà précédemment utilisée (ici "Cou cou  J M  B") et de voir, en la dupliquant, si le temps d'exécution et le nombre d'itérations varient. +

En voici le tableau adéquat :

|===
| *Chaînes de caractères analysées* | *Résultat de l'algorithme* | *Résultats attendus* | *Temps d'exécution* | *Nombre d'itérations*
| ``'C'`` | Test passé ✓ | ``'C'`` | ✘ | 2
| ``'Cou_cou\__J_M__B'`` | Test passé ✓ | ``'Coucou\__JM__B'`` | ✘ | 28
| ``'_Cou_cou\__J_M__B_'`` | Test passé ✓| ``'Coucou\__JM__B'`` | ✘ | 30
| ``'Cou_cou\__J_M__B'`` (dupliquée 5x) | Test passé ✓ | ``'Coucou\__JM__B'`` (dupliquée 5x) | ✘ | 140
| ``'Cou_cou\__J_M__B'`` (dupliquée 10x) | Test passé ✓ | ``Coucou\__JM__B`` (dupliquée 10x) | ✘ | 280
|===

Nous pouvons ainsi remarquer que le temps d'exécution augmente au fur et à mesure que la chaîne de caractère devient également importante.


=== Sobriété n°162 (langage Python)

==== Prérequis
[.text-justify]

[source, python]
----
----

[.text-justify]

[.text-justify]

==== Reproductibilité
[.text-justify]

[.text-justify]

==== Analyse
[.text-justify]

===== Lisibilité du code
[.text-justify]

===== Qualité du code
[.text-justify]
Visiblement, aucune erreur n'est à constater sur cette solution algorithmique. +
D'après *Codacy*, le fichier ``sobriete-162.py`` est noté "A".

image::/rapport/images/sobriete-162.PNG[]

===== Sobriété numérique
[.text-justify]

===== Efficacité et temps d'exécution
[.text-justify]

=== Sobriété n°166 (langage C)

==== Prérequis
[.text-justify]
Deux prérequis sont alors nécessaires à l'analyse du fichier ``sobriete-166.c`` :

____
● Un compilateur *GCC* en langage C sous Windows ; +
● Une librairie prénommée *<time.h>* à implémenter dans le code source pour l'analyse du temps d'exécution de la solution algorithmique proposée.
____

==== Reproductibilité et références
[.text-justify]
*Compilateur GCC :*

[.text-justify]
Pour l'utilisation du compilateur *GCC* dans votre terminal, je vous invite à installer la plate-forme de distribution et de construction de logiciels pour Windows *MSYS2* en http://feaforall.com/install-c-language-gcc-compiler-windows/[__cliquant ici__]. L'ensemble des étapes d'installation seront indiquées. +

[.text-justify]
Bien qu'il soit aisé d'installer facilement l'ensemble des packages nécessaires, il est également intéressant de savoir comment utiliser le compilateur *GCC* directement depuis votre terminal Windows : il est alors nécessaire que vous ajoutiez vos exécutables à votre PATH Windows. +

[.text-justify]
La procédure à suivre vous est proposée en bas de page sur l'article http://feaforall.com/install-c-language-gcc-compiler-windows/[__suivant__].

*Librairie <time.h> :*

[.text-justify]
Pour ainsi évaluer le temps d'exécution que votre algorithme puisse prendre afin d'en déterminer son efficacité, une librairie en langage C permet cette évaluation : la librairie *<time.h>*. +
Pour son importation, veuillez à rajouter la ligne suivante en en-tête du code source :

[source, c]
----
#include <time.h>
----

Une fois l'importation de cette librairie, il vous faut l'utiliser. Le programme ici proposé étant réalisé dans un ``main``, nous nous contenterons de rajouter les informations nécessaires dans celui-ci. Pour ce faire, déclarez une variable de type flottant, au début de la fonction ``main`` puis, retournez simplement la valeur prise par votre programme en fin de votre fonction :

[source, c]
----
//Déclarations de variables de test
  float time = 0;
  
  [...]
  
//Affichage des tests :
  time = clock();
  printf("\nTemps d'execution : %.2f ms", time);
  
  return 0; 
----

*Autres :*

Enfin, il en va également de même pour connaître le nombre d'itérations de votre programme, autrement dit, combien de fois est réalisée votre condition en fonction de la chaîne de caractère renseignée. +

Pour ce faire, veuillez à déclarer une variable de type entier au début de votre ``main`` puis, incrémentez cette valeur *au moment où* l'analyse de votre chaîne de caractère avance également et enfin, veuillez retourner votre résultat pour connaître le nombre de fois où vos conditions ont été exécutée :

[source, c]
----
//Déclarations de variables de test
  int nbIterations = 0;
  
  [...]
  
//Dans les conditions :
  nbIterations++;
  
  [...]
  
//Affichage des tests
  printf("\nNombre d'itérations : %d", nbIterations);
----

[.text-justify]

[.text-justify]

==== Analyse
[.text-justify]

===== Lisibilité du code
[.text-justify]
Bien que cela figure comme un avis subjectif, cette solution algorithmique n'est pour autant pas très explicite à comprendre. En effet, aucune javadoc n'a été réalisée afin que l'utilisateur réutilisant cette même solution, puisse comprendre la manière employée pour résoudre le problème. +

[.text-justify]
De plus, les conditions de vérification sont également très longues, avec une syntaxe jusque-là peu commune de la part du développeur. +
Celle-ci prend la forme suivante : ``[...] ? [...] : [...]``. +

[.text-justify]
Enfin, l'utilisation d'un tableau à double entrée n'est pas nécessairement très instructif, d'autant plus dans son utilisation ici-même. +
Concrètement, la chaîne de caractère sera toujours la même lors de l'analyse, bien que celle-ci se réalise étape par étape sur les caractères constituant cette même chaîne de caractère. Il est alors inutile de renseigner constamment comme premier élément, la même chaîne de caractère.

===== Qualité du code
[.text-justify]
Visiblement, aucune erreur n'est à constater sur cette solution algorithmique. +
D'après *Codacy*, le fichier ``sobriete-166.c`` est noté "A".

image::/rapport/images/sobriete-166.PNG[]

===== Sobriété numérique
[.text-justify]

===== Efficacité et temps d'exécution
[.text-justify]
Pour alors évaluer l'efficacité et le temps d'exécution de la solution algorithmique, un ensemble de tests est alors réalisé. +
Pour ces tests, j'ai procédé à prendre une chaîne de caractère déjà précédemment utilisée (ici "Cou cou  J M  B") et de voir, en la dupliquant, si le temps d'exécution et le nombre d'itérations varient. +

En voici le tableau adéquat :

|===
| *Chaînes de caractères analysées* | *Résultat de l'algorithme* | *Résultats attendus* | *Temps d'exécution* | *Nombre d'itérations*
| ``'C'`` | Test passé ✓ | ``'C'`` | 15.00ms | 1
| ``'Cou_cou\__J_M__B'`` | Test invalide ✘ | ``'Coucou\__JM__B'`` | 30.00ms | 3
| ``'_Cou_cou\__J_M__B_'`` | Test invalide ✘ | ``'Coucou\__JM__B'`` | 30.00ms | 3
| ``'Cou_cou\__J_M__B'`` (dupliquée 5x) | Test invalide ✘ | ``'Coucou\__JM__B'`` (dupliquée 5x) | 30.00ms | 3
| ``'Cou_cou\__J_M__B'`` (dupliquée 10x) | Test invalide ✘ | ``Coucou\__JM__B`` (dupliquée 10x) | 30.00ms | 3
|===

[.text-justify]
Ainsi, dès lors que la chaîne de caractère est dupliquée, le temps ainsi que le nombre d'itérations reste le même et pour cause : l'algorithme ne fonctionne pas lorsque l'on met un ou plusieurs espaces dans la chaîne de caractère. +
Dès lors qu'une chaîne de caractère est située au début, l'algorithme ne semble visiblement pas traiter le cas, passant directement au premier morceau de cette chaîne.

[.text-justify]
Autrement dit, il prendra seulement en considération le début de la chaîne de caractère non séparée du reste de celle-ci par un espace. De ce fait, traitant alors constamment la même chaîne de caractère, la complexité du programme ``sobriete-166.c`` semble se rapprocher de *O(1)*, bien que celle-ci soit complètement faussée car le résultat attendu ne correspond pas à la demande souhaitée.

== Catégorie "Efficacité"

=== Efficacité n°43 (langage Java)

==== Prérequis
[.text-justify]

[source, java]
----
----

[.text-justify]

[.text-justify]

==== Reproductibilité
[.text-justify]

[.text-justify]

==== Analyse
[.text-justify]

===== Lisibilité du code
[.text-justify]

===== Qualité du code
[.text-justify]

image::/rapport/images/efficacite-43.PNG[]

===== Sobriété numérique
[.text-justify]

===== Efficacité et temps d'exécution
[.text-justify]

=== Efficacité n°90 (langage Java)

==== Prérequis
[.text-justify]

[source, java]
----
----

[.text-justify]

[.text-justify]

==== Reproductibilité
[.text-justify]

[.text-justify]

==== Analyse
[.text-justify]

===== Lisibilité du code
[.text-justify]

===== Qualité du code
[.text-justify]

image::/rapport/images/efficacite-90.PNG[]

===== Sobriété numérique
[.text-justify]

===== Efficacité et temps d'exécution
[.text-justify]

=== Efficacité n°106 (langage Python)

==== Prérequis
[.text-justify]

[source, python]
----
----

[.text-justify]

[.text-justify]

==== Reproductibilité
[.text-justify]

[.text-justify]

==== Analyse
[.text-justify]

===== Lisibilité du code
[.text-justify]

===== Qualité du code
[.text-justify]

image::/rapport/images/efficacite-106.PNG[]

===== Sobriété numérique
[.text-justify]

===== Efficacité et temps d'exécution
[.text-justify]

=== Efficacité n°131 (langage Java)

==== Prérequis
[.text-justify]

[source, java]
----
----

[.text-justify]

[.text-justify]

==== Reproductibilité
[.text-justify]

[.text-justify]

==== Analyse
[.text-justify]

===== Lisibilité du code
[.text-justify]

===== Qualité du code
[.text-justify]

image::/rapport/images/efficacite-131.PNG[]

===== Sobriété numérique
[.text-justify]

===== Efficacité et temps d'exécution
[.text-justify]

== Catégorie "Simplicité"

=== Simplicité n°11 (langage Java)

==== Prérequis
[.text-justify]

[SOURCE, java]
----
----

[.text-justify]

[.text-justify]

==== Reproductibilité
[.text-justify]

[.text-justify]

==== Analyse
[.text-justify]

===== Lisibilité du code
[.text-justify]

===== Qualité du code
[.text-justify]
De ce qui peut être constaté, quelques erreurs mineurs ainsi qu'une erreur moyenne sont à constater sur cette solution algorithmique par *Codacy* : +

*Erreurs mineures :*
____
● Le nom de la classe utilitaire 'Erase1' ne correspond pas à '[AZ][a-zA-Z0-9] ; +
● Toutes les classes, interfaces, énumérations et annotations doivent appartenir à un package nommé ; +
____

*Erreur moyenne :*
____
● La méthode 'erase1(String)' a une complexité NPath (nombre de chemins acycliques) de 384, le seuil actuel est de 200 ;
____

D'après *Codacy*, le fichier ``simplicite-11.java`` est noté "B".

image::/rapport/images/simplicite-11.PNG[]

===== Sobriété numérique
[.text-justify]

===== Efficacité et temps d'exécution
[.text-justify]

=== Simplicité n°39 (langage Java)

==== Prérequis
[.text-justify]

[source, java]
----
----

[.text-justify]

[.text-justify]

==== Reproductibilité
[.text-justify]

[.text-justify]

==== Analyse
[.text-justify]

===== Lisibilité du code
[.text-justify]

===== Qualité du code
[.text-justify]
Visiblement, aucune erreur n'est à constater sur cette solution algorithmique. +
D'après *Codacy*, le fichier ``simplicite-39.java`` est noté "A".

image::/rapport/images/simplicite-39.PNG[]

===== Sobriété numérique
[.text-justify]

===== Efficacité et temps d'exécution
[.text-justify]

=== Simplicité n°56 (langage Java)

==== Prérequis
[.text-justify]

[source, java]
----
----

[.text-justify]

[.text-justify]

==== Reproductibilité
[.text-justify]

[.text-justify]

==== Analyse
[.text-justify]

===== Lisibilité du code
[.text-justify]

===== Qualité du code
[.text-justify]

image::/rapport/images/simplicite-56.PNG[]

===== Sobriété numérique
[.text-justify]

===== Efficacité et temps d'exécution
[.text-justify]

=== Simplicité n°71 (langage Java)

==== Prérequis
[.text-justify]

[source, java]
----
----

[.text-justify]

[.text-justify]

==== Reproductibilité
[.text-justify]

[.text-justify]

==== Analyse
[.text-justify]

===== Lisibilité du code
[.text-justify]

===== Qualité du code
[.text-justify]

image::/rapport/images/simplicite-71.PNG[]

===== Sobriété numérique
[.text-justify]

===== Efficacité et temps d'exécution
[.text-justify]

== Classement

Voici donc le classement final selon les catégories :

|===
|Catégorie |Solution algorithmique |Position |Notation

.4+<.>|Sobriété
|1
|
|

|2
|
|

|3
|
|

|4
|
|


.4+<.>|Efficacité
|5
|
|

|6
|
|

|7
|
|

|8
|
|

.3+<.>|Simplicité
|9
|
|

|10
|
|

|11
|
|
|===

== Exemple de code

=== Efficacité n°21 (python)

==== Prérequis
[.text-justify]
Ajouter le code suivant tout en haut du fichier ``test.py`` : +

[source, python]
----
import sys
sys.path.append('analyse/solutions/') # import python files from path 'analyse/solutions'
from efficacite21 import erase
----

[.text-justify]
Il permet de vérifier que le programme traite bien tous les cas donnés. +
 +

[.text-justify]
Le fichier ``analyse.py`` du répertoire ``analyse`` permet d'obtenir les temps d'exécutions du programme en fonction de chaînes générées aléatoirement de tailles données.


==== Reproductibilité
[.text-justify]
Lancer le code de ``test.py``, le programme devrait s'exécuter même si une erreur de compilation est relevée dans la close donnée dans les prérequis. Vérifier que le programme traite de tous les cas donnés.

[.text-justify]
Lancer le code de ``analyse.py``, le programme devrait s'exécuter même si une erreur de compilation est relevée dans la close donnée dans les prérequis. Analyser les temps d'exécutions en fonction des différentes tailles de chaînes.

==== Analyse
[.text-justify]
[red]#Ce code ne passe pas tous les tests !#

===== Lisibilité du code
[.text-justify]

===== Qualité du code
[.text-justify]

===== Sobriété numérique
[.text-justify]

===== Efficacité et temps d'exécution
[.text-justify]
Les temps d'exécutions analysés via le programme ``analyse.py`` semblent être inconstants. La complexité du programme ``efficacite21`` dépend du nombre d'espace dans la chaîne donnée. Cette dernière semble se rapprocher le plus de *O(2n)*.
