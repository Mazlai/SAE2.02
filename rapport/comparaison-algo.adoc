:toc:
:toc-placement!:
:toc-title: Table des matières
:sectnums:

image::/rapport/images/logo_transparent.png[]

= SAE 2.02 - Comparaison d'approches algorithmiques

_Réalisé par FERNANDEZ Mickael (4A)_

toc::[]

{empty} +

[NOTE]
[.text-justify]
Les fichiers ont été renommés afin d'enlever le caractère ``-`` qui posait problème lors de l'importation des fichiers dans certains codes d'analyse.

*NOTATION*
|===
|*Cas*|*Points*
|Ne compile/s'exécute pas|0
|Ne passe pas les tests fournis ou a rate certains cas|1
|Meilleur algo de la catégorie|5
|2nd algo|4
|3e algo|3
|4e algo|2
|===
En cas d'ex-aequo, même note. (5/5/3/2 par exemple).

{empty} +



== Efficacité n°21 (python)

=== Prérequis
[.text-justify]
Ajouter le code suivant tout en haut du fichier ``test.py`` : +

[SOURCE, python]
----
import sys
sys.path.append('analyse/solutions/') # import python files from path 'analyse/solutions'
from efficacite21 import erase
----

[.text-justify]
Il permet de vérifier que le programme traite bien tous les cas donnés. +
 +

[.text-justify]
Le fichier ``analyse.py`` du répertoire ``analyse`` permet d'obtenir les temps d'exécutions du programme en fonction de chaînes générées aléatoirement de tailles données.


=== Reproductibilité
[.text-justify]
Lancer le code de ``test.py``, le programme devrait s'exécuter même si une erreur de compilation est relevée dans la close donnée dans les prérequis. Vérifier que le programme traite de tous les cas donnés.

[.text-justify]
Lancer le code de ``analyse.py``, le programme devrait s'exécuter même si une erreur de compilation est relevée dans la close donnée dans les prérequis. Analyser les temps d'exécutions en fonction des différentes tailles de chaînes.


=== Analyse
[.text-justify]
[red]#Ce code ne passe pas tous les tests !#

==== Efficacité et temps d'exécution
[.text-justify]
Les temps d'exécutions analysés via le programme ``analyse.py`` semblent être inconstants. La complexité du programme ``efficacite21`` dépend du nombre d'espace dans la chaîne donnée. Cette dernière semble se rapprocher le plus de *O(2n)*.
