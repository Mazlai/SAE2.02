:toc:
:toc-placement!:
:toc-title: Table des matières
:sectnums:

image::/rapport/images/logo_transparent.png[]

= SAE 2.02 - Comparaison d'approches algorithmiques

_Réalisé par FERNANDEZ Mickael (4A)_

toc::[]

== Objectif

[.text-justify]
Parmi l'ensemble des solutions algorithmiques proposées, il est nécessaire de les explorer en ayant une approche s'intéressant à l'implémentation bas niveau (structures de données, etc.) ainsi qu'à haut niveau (précision des résultats, etc.)

[NOTE]
[.text-justify]
Les solutions algorithmiques sont des fichiers de divers langages (C, Python, Java) dont le but était de seulement retirer les espaces individuels, qu'importe de l'emplacement de ceux-ci.

*NOTATION*

En voici la grille de notation :

|===
|*Cas*|*Points*
|Ne compile/s'exécute pas|0
|Ne passe pas les tests fournis ou a rate certains cas|1
|Meilleur algo de la catégorie|5
|2nd algo|4
|3e algo|3
|4e algo|2
|===
En cas d'ex-aequo, même note. (5/5/3/2 par exemple).

== Prérequis
Plusieurs prérequis ont alors été nécessaire à la réalisation de l'ensemble des analyses des fichiers :
____
*En C :* +
● Un compilateur *GCC* en langage C sous Windows ; +
● Un IDE (ici, CodeBlocks était utilisé pour le temps d'exécution sur le fichier ``sobriete-57.c``). +
● Un IDE collaboratif (ici, repl.it était utilisé pour la sobriété). +

*En Java :* +
● Un IDE (ici Eclipse, bien que vous puissiez en choisir un autre). +

*En Python :*
● Un IDE collaboratif (ici, repl.it était utilisé pour la sobriété). +
● Un IDE (ici EduPython), bien que vous puissiez en choisir un autre).
____

== Reproductibilité et références
[.text-justify]
*Compilateur GCC :*

[.text-justify]
Pour l'utilisation du compilateur *GCC* dans votre terminal, je vous invite à installer la plate-forme de distribution et de construction de logiciels pour Windows *MSYS2* en http://feaforall.com/install-c-language-gcc-compiler-windows/[__cliquant ici__]. L'ensemble des étapes d'installation seront indiquées. +

[.text-justify]
Bien qu'il soit aisé d'installer facilement l'ensemble des packages nécessaires, il est également intéressant de savoir comment utiliser le compilateur *GCC* directement depuis votre terminal Windows : il est alors nécessaire que vous ajoutiez vos exécutables à votre PATH Windows. +

[.text-justify]
La procédure à suivre vous est proposée en bas de page sur l'article http://feaforall.com/install-c-language-gcc-compiler-windows/[__suivant__].

*CodeBlocks :*

[.text-justify]
CodeBlocks ne nécessite pas de configuration particulière pour pouvoir compiler et exécuter un programme, ici en C. L'avantage de son utilisation est que le temps d'exécution est automatiquement calculé. Ainsi, pour paramétrer votre fichier ``sobriete-57.c``, il est d'abord nécessaire de l'installer. Pour toutes ces étapes, il suffit de :
____
● Se rendre sur le site de https://www.codeblocks.org/downloads/[__Code::Blocks__] et aller dans la section "Downloads" puis "Download the binary release" ; +
● Paramétrez alors votre logiciel CodeBlocks selon vos préférences ; +
● Une fois CodeBlocks d'ouvert, sélectionnez _"File"_ > _"Open..."_ et enfin, trouvez votre fichier ; +
● Exécutez votre code.
____

*Repl.it :*

Repl.it ne nécessite pas de configuration particulière pour pouvoir compiler et exécuter un programme, quel que soit le langage utilisé. + 
Pour paramétrer votre fichier, il suffit de :
____
● Créer un compte repl.it ou l'associer avec un compte Google, GitHub, etc. +
● Créer un "Repl" dont votre template sera en C, avec un titre au choix. +
● Déposer votre code en C et exécutez-le.
____

*Eclipse :*

Eclipse est un IDE qui ne nécessite pas de configuration particulière pour l'exécuter. Tout de même, pour exécuter en revanche un fichier Java, il est nécessaire de définir son environnement de travail et de paramétrer certaines fonctionnalités.

Tout d'abord, rendez-vous sur le site d'https://www.eclipse.org/downloads/[__Eclipse__] et télécharger la version recommandée. Vous définirez alors votre chemin pour savoir d'où vous pourrez exécuter Eclipse et vous paramétrez cet IDE comme bon vous semble.

Pour l'analyse de cette solution algorithmique, il est d'abord nécessaire d'avoir un environnement de travail (workspace). Vous pouvez tout simplement en créer un.
De là, vous n'avez qu'à vous rendre sur la https://github.com/IUT-Blagnac/sae2-02-Mazlai[__page principale__] de cette SAÉ sur GitHub, et de cliquer sur _"Code"_ > _"Download ZIP"_. De là, vous n'avez qu'à extraire celui-ci. 

Vous créez alors un nouveau projet du nom que vous souhaitez, et dans le dossier "src", vous n'avez qu'à glisser les packages déjà présents dans le zip à savoir : +

____
● main.java.eraser ; +
● test.java.
____

WARNING: Il se peut que vous ayez une erreur de buildpath ou que vous n'ayez pas de JUnit paramétré.

● _Si vous avez une erreur de buildpath :_

→ Faites un clic droit sur le projet que vous avez précédemment créé et allez dans "Properties" > "Java Build Path" > "Librairies". +
→ De ce fait, cliquez sur _"Modulepath"_ > _"Add Library"_ > _"JRE System Library"_ > _"Workspace default JRE"_. Et enfin, terminez. Vous cliquerez pour terminer sur _"Apply and close"_. +
→ Vous cliquerez alors sur "Order and export" et sélectionnerez le nouveau JRE que vous avez ajouté. 

● _Si vous avez une erreur de JUnit :_

→ Faites un clic droit sur le projet que vous avez précédemment créé et allez dans _"Properties"_ > _"Java Build Path"_ > _"Librairies"_. +
→ De ce fait, cliquez sur _"Classpath"_ > _"Add External JARs..."_ et vous naviguerez pour trouver votre JUnit. En règle générale, il se situera dans _"Java"_ > _"Eclipse"_ > _"Plugins"_ > _"org.junit_[votre version]"_. Enfin, vous cliquerez sur _"Apply and close"_. +
→ Vous cliquerez alors sur _"Order and export"_ et sélectionnerez le nouveau JAR que vous avez ajouté.

*EduPython :*

EduPython est un IDE gratuit et simple d'utilisation, permettant une bonne prise en main pour les débutants, à la programmation en Python.
Pour l'utiliser, se rendre sur la https://edupython.tuxfamily.org/#t%C3%A9l%C3%A9chargement[__page suivante__] et téléchargez la dernière version complète.

De là, paramétrez votre IDE et ouvrez-le. Vous n'aurez simplement qu'à récupérer les fichiers Python dont vous souhaitez analyser (ici-même présents dans le dossier ``analyse``) et de ne pas oublier d'importer les modules ou packages nécessaires pour exécuter votre code depuis une autre classe.

== Catégorie "Sobriété"

=== Sobriété n°57 (langage C)

==== Sous-reproductibilité et références

*Autres :*

[.text-justify]
Il est intéressant de connaître le nombre d'itérations de votre programme, autrement dit, combien de fois est réalisée votre condition en fonction de la chaîne de caractères renseignée. +

[.text-justify]
Pour ce faire, veuillez à déclarer une variable au début de votre fonction puis, incrémentez cette valeur *au moment où* l'analyse de votre chaîne de caractères avance également et enfin, veuillez retourner votre résultat pour connaître le nombre de fois où vos conditions ont été exécutée :

[source, c]
----
//Déclarations de variables de test
  int nbIterations = 0;
  
  [...]
  
//Dans les conditions :
  nbIterations++;
  
  [...]
  
//Affichage des tests
  printf("\nNombre d'itérations : %d", nbIterations);
----

==== Analyse
[.text-justify]
Parmi l'ensemble des tests réalisés, le code les passe avec succès sans qu'aucune erreur ne soit à déplorer à la fois sur le résultat attendu mais également sur le code en lui-même.

===== Lisibilité du code - Optionnel
[.text-justify]
En terme de lisibilité de code, bien qu'une javadoc soit absente afin de détailler le fonctionnement de la fonction ``erase``, celui-ci paraît très compréhensible car une distinction nette entre les déclarations de variables, les conditions ainsi que les résultats est présente. +

[.text-justify]
Par ailleurs, les conditions de vérification sont également très claires. Le code est bien décortiqué et compréhensible notamment dans le fait que le développeur ait utilisé une nouvelle chaîne de caractères dépendante de la chaîne de caractères initiale en prenant les modifications à apporter mais également dans l'analyse de la chaîne de caractères en question. Il est clair de voir que les différents *if*, traitent différents cas possibles de la chaîne, tout en veillant à ne pas dépasser la fin de celle-ci, chose gérée dans la bouche *while*.

===== Qualité du code - Optionnel
[.text-justify]
De ce qui peut être constaté, quelques erreurs mineurs sont à constater sur cette solution algorithmique par *Codacy* : +

*Erreurs mineures :*
____
● Une ingérence des chaînes qui ne sont pas terminées par \0 ; si on lui en donne un, il peut effectuer une surlecture (cela pourrait provoquer un plantage s'il n'est pas protégé) ; +
● La condition 'chaine[i]==' '' est _visiblement_ toujours vraie. +
____

D'après *Codacy*, le fichier ``sobriete-57.c`` est noté "B".

image::/rapport/images/sobriete-57.PNG[]

===== Sobriété numérique
[.text-justify]
L'utilisation de repl.it a été avantageuse dans le fait d'évaluer la sobriété numérique d'un programme. En effet, sur celu-ci, on peut retrouver des caractéristiques en corrélation avec l'utilisation des ressources, et notamment de l'utilisation du CPU, de la RAM ou encore du stockage. Bien que la différence puisse être minime dans l'utilisation de la RAM car, bien qu'un fichier soit vide, cela ne fait pas pour autant varier la RAM, cela nous permet malgré tout de pouvoir en effectuer une analyse intéressante. En voici sa consommation :

image::/rapport/images/sob2.PNG[]

La mémoire d'un programme C possède une disposition bien particulière puisqu'elle comprend différente sections. 
Pour comprendre davantage la disposition d'une mémoire typique d'un processus en cours d'exécution, veuillez https://www.geeksforgeeks.org/memory-layout-of-c-program/[__cliquer ici__].

Ainsi, pour le calcul de la sobriété numérique, il est nécessaire de voir la consommation utilisée par le fichier compilé (.exe). Ici, elle sera calculée depuis le terminal, en exécutant la commande ``size [file]``. +

Ainsi, la taille du fichier totale (ici en octets) comprend les segments *data*, *text* et *bss*, constituant la mémoire d'un programme C. +
On établira alors une moyenne selon les différentes chaînes de caractères renseignées.

En voici le tableau de cette sobriété numérique :

|===
| *Chaînes de caractères analysées* | *Mémoire consommée* | *Mémoire moyenne consommée*

|``'C'`` 
| 5753 octets
.5+<.>| Environ 5805 octets (selon les chaînes de caractères renseignées)

|``'Cou_cou\__J_M__B'`` 
| 5769 octets

|``'\_Cou_cou\__J_M__B_'`` 
| 5771 octets

|``'Cou_cou\__J_M__B'`` (dupliquée 5x) 
| 5833 octets

|``'Cou_cou\__J_M__B'`` (dupliquée 10x) 
| 5897 octets
|===

===== Efficacité et temps d'exécution - Optionnel
[.text-justify]
Pour alors évaluer l'efficacité et le temps d'exécution de la solution algorithmique, un ensemble de tests est alors réalisé. +
Pour ces tests, j'ai procédé à prendre une chaîne de caractères déjà précédemment utilisée (ici "Cou cou  J M  B") et de voir, en la dupliquant, si le temps d'exécution et le nombre d'itérations varient. +

En voici le tableau adéquat :

|===
| *Chaînes de caractères analysées* | *Résultat de l'algorithme* | *Résultats attendus* | *Temps d'exécution* | *Nombre d'itérations*

|``'C'`` 
|Test passé ✓ 
|``'C'`` 
|0.134s 
|2

|``'Cou_cou\__J_M__B'`` 
|Test passé ✓ 
|``'Coucou\__JM__B'`` 
|1.030s 
|28

|``'\_Cou_cou\__J_M__B_'`` 
|Test passé ✓
|``'Coucou\__JM__B'`` 
|1.299s 
|30

|``'Cou_cou\__J_M__B'`` (dupliquée 5x) 
|Test passé ✓ 
|``'Coucou\__JM__B'`` (dupliquée 5x) 
|1.356s 
|140

|``'Cou_cou\__J_M__B'`` (dupliquée 10x) 
|Test passé ✓ 
|``Coucou\__JM__B`` (dupliquée 10x) 
|1.423s 
|280
|===

[.text-justify]
Nous pouvons ainsi remarquer que le temps d'exécution augmente au fur et à mesure que la chaîne de caractères devient également importante. Pour autant, ce temps d'exécution semble relativement variable et peu corrélé en fonction de la longueur de la chaîne de caractères car, celle-ci l'était également dès lors que l'on exécutait le programme : ce temps d'exécution est évalué par une moyenne, réalisée 5 fois pour car chaîne de caractères analysée.

[.text-justify]
Pour autant, il semblerait que la complexité soit plus facile à calculer en fonction du nombre d'itérations, car le rapprochement semble plus compréhensible et visible. En effet, il est facile de déduire la valeur (ou nombre d'itérations) des caractères utilisés par ce programme : 
____
● 1 pour l'espace simple ; +
● 2 pour un caractère autre que l'espace simple (une lettre par exemple) ; +
● 3 pour un espace s'il est situé entre deux autres espaces. 
____

[.text-justify]
Comme le calcul du nombre d'itérations se fait également selon la longueur de la chaîne de caractères, il semblerait que la complexité du programme ``sobriete-57.c`` soit d'une complexité de n + x + y + z) avec n, la longueur de la chaîne de caractères, x un espace simple, y un caractère autre qu'un simple espace, z un espace situé entre deux autres (ou suivi d'un autre). L'ordre de grandeur serait alors de *O(n)*.

=== Sobriété n°162 (langage Python)

==== Sous-reproductibilité et références

*Module timeit :*

[.text-justify]
timeit est un module permettant de fournir de façon simple le temps d'exécution de fragments de code Python tout en évitant un certain nombre de problèmes classiques liés à la mesure des temps d'exécution.

Pour son importation, veuillez importer ce module en en-tête du code source :

[source, python]
----
import timeit
----
[.text-justify]
Désormais, il vous suffit de l'utiliser. Tout d'abord, veuillez à mettre en commentaire votre fonction et à la stocker dans une variable dont son choix de nom est complètement libre. De là, vous renseignerez directement dans les paramètres de la fonction, la chaîne de caractères que vous souhaiterez analyser. +
Enfin, il vous suffit qu'à reconnaître cette variable et à effectuer des tours de boucle selon votre envie pour en calculer votre temps d'exécution.

Pour l'analyse de cette solution algorithmique, veuillez à reproduire le code suivant :

[source, python]
----
moncode = '''
def bonmot2(mot="Cou cou  J M  B"):
    if mot == " " or mot == "":
        return ("")
    else:
        if mot[0] == " " and mot[1] != " ":
            mot = mot[:0] + "" + mot[ 1:]

        if mot[-1] == " " and mot[-2] != " ":
            mot = mot[:-1] + ""

        ajout = 0
        taille = len(mot)
        i=0
        while i<taille-1:
            if mot[i] == " ":
                if mot[i + 1] != " " and mot[i - 1] != " ":
                    mot = "  " + mot[:i] + "" + mot[i + 1:]
                    ajout += 2
                    taille+=1
            i+=1

        mot = mot[(ajout):]

        return(mot)
'''

print("Temps d'exécution du programme : ",
       timeit.timeit(stmt = moncode,
                     number = 100000
                     ))
----

*Réalisation de tests :*

[.text-justify]
Pour faire que les tests que vous avez posé puissent être réalisés, veuillez ajouter le code suivant tout en haut du fichier ``test.py`` (situé au chemin renseigné ci-dessous et en considérant que le workspace utilisé est celui du *GitHub*) : +

[source, python]
----
import sys
sys.path.append('analyse/Sobriété/Python/sobriete-162')
from sobriete162 import bonmot2
----

[.text-justify]
Il permet de vérifier que le programme traite bien tous les cas donnés. +

*Autres :*

[.text-justify]
Il est intéressant de connaître le nombre d'itérations de votre programme, autrement dit, combien de fois est réalisée votre condition en fonction de la chaîne de caractères renseignée. +

[.text-justify]
Pour ce faire, veuillez à déclarer une variable au début de votre fonction puis, incrémentez cette valeur *au moment où* l'analyse de votre chaîne de caractères avance également et enfin, veuillez retourner votre résultat pour connaître le nombre de fois où vos conditions ont été exécutée :

[source, python]
----
//Déclarations de variables de test
  nbIterations = 0;
  
  [...]
  
//Dans les conditions :
  nbIterations = nbIterations + 1;
  
  [...]
  
//Affichage des tests
  print("Nombre d'itérations ", nbIterations);
----

==== Analyse
[.text-justify]
Parmi l'ensemble des tests passés pour ce fichier, la fonctionnalité du code les passe avec succès sans qu'une erreur ne soit signalé en terme de qualité, c'est-à-dire à la fois sur le résultat attendu mais également sur le code en lui-même.

===== Lisibilité du code - Optionnel
[.text-justify]
Une nouvelle fois constaté, le développeur a oublié de réaliser un javadoc car au premier abord, le code ne semble pas évident à comprendre. Ainsi, dans l'aspect du code, je trouve que l'ensemble des informations sont très condensées car son code n'est pas aéré mais également, certaines conditions méritent également d'être rassemblées. +

Enfin, pour les conditions de vérifications, le code n'est pas exceptionnement compliqué à comprendre, d'où le fait que n'importe qui serait capable de comprendre ce qu'il se passe.

===== Qualité du code - Optionnel
[.text-justify]
Visiblement, aucune erreur n'est à constater sur cette solution algorithmique. +
D'après *Codacy*, le fichier ``sobriete-162.py`` est noté "A".

image::/rapport/images/sobriete-162.PNG[]

===== Sobriété numérique
[.text-justify]
L'utilisation de repl.it a été avantageuse dans le fait d'évaluer la sobriété numérique d'un programme. En effet, sur celu-ci, on peut retrouver des caractéristiques en corrélation avec l'utilisation des ressources, et notamment de l'utilisation du CPU, de la RAM ou encore du stockage. Bien que la différence puisse être minime dans l'utilisation de la RAM car, bien qu'un fichier soit vide, cela ne fait pas pour autant varier la RAM, cela nous permet malgré tout de pouvoir en effectuer une analyse intéressante. En voici sa consommation :

image::/rapport/images/sob3.PNG[]

Il est ainsi logique de constater que les programmes Python soient bien plus lents et utilisant plus de mémoire.
Ces raisons étant que Python est un langage interprété, tandis que le C est compilé mais également que Python n'ait pas de primitives ainsi que de builtin types (int, float, etc.) étant déjà des objets.

===== Efficacité et temps d'exécution - Optionnel
[.text-justify]
Pour alors évaluer l'efficacité et le temps d'exécution de la solution algorithmique, un ensemble de tests est alors réalisé. +
Pour ces tests, j'ai procédé à prendre une chaîne de caractères déjà précédemment utilisée (ici "Cou cou  J M  B") et de voir, en la dupliquant, si le temps d'exécution et le nombre d'itérations varient. +

En voici le tableau adéquat :

|===
| *Chaînes de caractères analysées* | *Résultat de l'algorithme* | *Résultats attendus* | *Temps d'exécution* | *Nombre d'itérations*

|``'Cou_cou\__J_M__B'`` 
|Test passé ✓ 
|``'Coucou\__JM__B'`` 
|Environ 0.0000006s soit 0.0006ms
|34

|``'\_Cou_cou\__J_M__B_'`` 
|Test passé ✓
|``'Coucou\__JM__B'`` 
|Environ 0.0000008s soit 0.0008ms
|3600

|``'Cou_cou\__J_M__B'`` (dupliquée 100x) 
|Test passé ✓ 
|``'Coucou\__JM__B'`` (dupliquée 100x) 
|Environ 0.0000122s soit 0.0122ms
|13000

|``'Cou_cou\__J_M__B'`` (dupliquée 10000x) 
|Test passé ✓ 
|``Coucou\__JM__B`` (dupliquée 10000x) 
|Environ 0.001257s, soit 1.257ms
|36000

|``'Cou_cou\__J_M__B'`` (dupliquée 100000x) 
|Test passé ✓ 
|``'Coucou\__JM__B'`` (dupliquée 100000x) 
|Environ 0.0116124s, soit 11.6124ms
|360000
|===

[.text-justify]
Lorsque la chaîne de caractères est dupliquée, l'ensemble des tests à réaliser passent également.
[.text-justify]
Il prendra seulement en considération l'ensemble des caractères présents dans cette même liste. 

✘

=== Sobriété n°166 (langage C)

==== Sous-reproductibilité et références

*Librairie <time.h> :*

[.text-justify]
Pour ainsi évaluer le temps d'exécution que votre algorithme puisse prendre afin d'en déterminer son efficacité, une librairie en langage C permet cette évaluation : la librairie *<time.h>*. +
Pour son importation, veuillez à rajouter la ligne suivante en en-tête du code source :

[source, c]
----
#include <time.h>
----

[.text-justify]
Une fois l'importation de cette librairie, il vous faut l'utiliser. Le programme ici proposé étant réalisé dans un ``main``, nous nous contenterons de rajouter les informations nécessaires dans celui-ci. Pour ce faire, déclarez une variable de type flottant, au début de la fonction ``main`` puis, retournez simplement la valeur prise par votre programme en fin de votre fonction :

[source, c]
----
//Déclarations de variables de test
  float time = 0;
  
  [...]
  
//Affichage des tests :
  time = clock();
  printf("\nTemps d'execution : %.2f ms", time);
  
  return 0; 
----

*Autres :*

[.text-justify]
Enfin, il en va également de même pour connaître le nombre d'itérations de votre programme, autrement dit, combien de fois est réalisée votre condition en fonction de la chaîne de caractères renseignée. +

[.text-justify]
Pour ce faire, veuillez à déclarer une variable de type entier au début de votre ``main`` puis, incrémentez cette valeur *au moment où* l'analyse de votre chaîne de caractères avance également et enfin, veuillez retourner votre résultat pour connaître le nombre de fois où vos conditions ont été exécutée :

[source, c]
----
//Déclarations de variables de test
  int nbIterations = 0;
  
  [...]
  
//Dans les conditions :
  nbIterations++;
  
  [...]
  
//Affichage des tests
  printf("\nNombre d'itérations : %d", nbIterations);
----

==== Analyse
[.text-justify]
Parmi l'ensemble des tests réalisés, le code les passe avec succès sans qu'aucune erreur ne soit à déplorer sur le code en lui-même. Pour autant, sur le résultat attendu, celui-ci ne respecte pas les attentes souhaitées car il semblerait la chaîne de caractères affichée ne soit uniquement que celle précédée d'un espace.

===== Lisibilité du code - Optionnel
[.text-justify]
Bien que cela figure comme un avis subjectif, cette solution algorithmique n'est pour autant pas très explicite à comprendre. En effet, aucune javadoc n'a été réalisée afin que l'utilisateur réutilisant cette même solution, puisse comprendre la manière employée pour résoudre le problème. +

[.text-justify]
De plus, les conditions de vérification sont également très longues, avec une syntaxe jusque-là peu commune de la part du développeur. +
Celle-ci prend la forme suivante : ``[...] ? [...] : [...]``. +

[.text-justify]
Enfin, l'utilisation d'un tableau à double entrée n'est pas nécessairement très instructif, d'autant plus dans son utilisation ici-même. +
Concrètement, la chaîne de caractères sera toujours la même lors de l'analyse, bien que celle-ci se réalise étape par étape sur les caractères constituant cette même chaîne de caractères. Il est alors inutile de renseigner constamment comme premier élément, la même chaîne de caractères.

===== Qualité du code - Optionnel
[.text-justify]
Visiblement, aucune erreur n'est à constater sur cette solution algorithmique. +
D'après *Codacy*, le fichier ``sobriete-166.c`` est noté "A".

image::/rapport/images/sobriete-166.PNG[]

===== Sobriété numérique
[.text-justify]
L'utilisation de repl.it a été avantageuse dans le fait d'évaluer la sobriété numérique d'un programme. En effet, sur celu-ci, on peut retrouver des caractéristiques en corrélation avec l'utilisation des ressources, et notamment de l'utilisation du CPU, de la RAM ou encore du stockage. Bien que la différence puisse être minime dans l'utilisation de la RAM car, bien qu'un fichier soit vide, cela ne fait pas pour autant varier la RAM, cela nous permet malgré tout de pouvoir en effectuer une analyse intéressante. En voici sa consommation :

image::/rapport/images/sob.PNG[]

[.text-justify]
La mémoire d'un programme C possède une disposition bien particulière puisqu'elle comprend différente sections. 
Pour comprendre davantage la disposition d'une mémoire typique d'un processus en cours d'exécution, veuillez https://www.geeksforgeeks.org/memory-layout-of-c-program/[__cliquer ici__].

Ainsi, pour le calcul de la sobriété numérique, il est nécessaire de voir la consommation utilisée par le fichier compilé (.exe). Ici, elle sera calculée depuis le terminal, en exécutant la commande ``size [file]``. +

Ainsi, la taille du fichier totale (ici en octets) comprend les segments *data*, *text* et *bss*, constituant la mémoire d'un programme C. +
On établira alors une moyenne selon les différentes chaînes de caractères renseignées.

En voici le tableau de cette sobriété numérique :

|===
| *Chaînes de caractères analysées* | *Mémoire consommée* | *Mémoire moyenne consommée*

|``'C'`` 
| 5897 octets
.5+<.>| 5897 octets

|``'Cou_cou\__J_M__B'`` 
| 5897 octets

|``'\_Cou_cou\__J_M__B_'`` 
| 5897 octets

|``'Cou_cou\__J_M__B'`` (dupliquée 5x) 
| 5897 octets

|``'Cou_cou\__J_M__B'`` (dupliquée 10x) 
| 5897 octets
|===

[.text-justify]
Le programme étant regroupé dans un main, il est difficile d'évaluer la mémoire d'un processus en cours d'exécution, d'autant plus quand le test de la chaîne de caractèrse ne peut que se faire depuis le terminal (après compilation du programme C en un fichier compilé .exe, puis exécution de celui-ci en renseignant la chaîne de caractères souhaitée). 

===== Efficacité et temps d'exécution - Optionnel
[.text-justify]
Pour alors évaluer l'efficacité et le temps d'exécution de la solution algorithmique, un ensemble de tests est alors réalisé. +
Pour ces tests, j'ai procédé à prendre une chaîne de caractères déjà précédemment utilisée (ici "Cou cou  J M  B") et de voir, en la dupliquant, si le temps d'exécution et le nombre d'itérations varient. +

En voici le tableau adéquat :

|===
| *Chaînes de caractères analysées* | *Résultat de l'algorithme* | *Résultats attendus* | *Temps d'exécution* | *Nombre d'itérations*

|``'C'`` 
|Test passé ✓ 
|``'C'`` 
|15.00ms 
|1

|``'Cou_cou\__J_M__B'`` 
|Test invalide ✘ 
|``'Coucou\__JM__B'`` 
|30.00ms 
|3

|``'\_Cou_cou\__J_M__B_'`` 
|Test invalide ✘ 
|``'Coucou\__JM__B'`` 
|30.00ms 
|3

|``'Cou_cou\__J_M__B'`` (dupliquée 5x) 
|Test invalide ✘ 
|``'Coucou\__JM__B'`` (dupliquée 5x) 
|30.00ms 
|3

|``'Cou_cou\__J_M__B'`` (dupliquée 10x) 
|Test invalide ✘ 
|``Coucou\__JM__B`` (dupliquée 10x) 
|30.00ms 
|3
|===

[.text-justify]
Ainsi, dès lors que la chaîne de caractères est dupliquée, le temps ainsi que le nombre d'itérations reste le même et pour cause : l'algorithme ne fonctionne pas lorsque l'on met un ou plusieurs espaces dans la chaîne de caractères. +
Dès lors qu'une chaîne de caractères est située au début, l'algorithme ne semble visiblement pas traiter le cas, passant directement au premier morceau de cette chaîne.

[.text-justify]
Autrement dit, il prendra seulement en considération le début de la chaîne de caractères non séparée du reste de celle-ci par un espace. De ce fait, traitant alors constamment la même chaîne de caractères, l'ordre de grandeur du programme ``sobriete-166.c`` semble se rapprocher de *O(1)*, bien que celle-ci soit complètement faussée car le résultat attendu ne correspond pas à la demande souhaitée.

== Catégorie "Efficacité"

=== Efficacité n°43 (langage Java)

==== Sous-reproductibilité et références

*Utilisation de nanoTime :*

[.text-justify]
L'utilisation de nanoTime est très intéressante. Celle-ci fait partie des méthodes que nous pouvons utiliser depuis l'utilisation générale des affichages à l'écran, aussi connu dans Java sous le nom de *System*.

[.text-justify]
Pour son utilisation, il est donc nécessaire de savoir à partir de quel moment il est intéressant d'évaluer ce temps et jusqu'à quand. Cette évaluation se fera alors pour l'exécution d'une fonction, tout dépendra des répétitions effectuées à son exécution (notamment pour avoir une évaluation précise sur ses temps d'exécution, nécessaires au calcul d'une complexité).

Sur votre ``Main.java``, veuillez ainsi rajouter les lignes de code suivantes :

[source, java]
----
long debut = System.nanoTime();

[...] //Exécution de votre fonction

long fin = System.nanoTime();
System.out.println((fin-debut)/1000000);
----

*Autres :*

[.text-justify]
Il est intéressant de connaître le nombre d'itérations de votre programme, autrement dit, combien de fois est réalisée votre condition en fonction de la chaîne de caractères renseignée. +

[.text-justify]
Pour ce faire, veuillez à déclarer une variable de type entier au début de votre fonction puis, incrémentez cette valeur *au moment où* l'analyse de votre chaîne de caractères avance également et enfin, veuillez retourner votre résultat pour connaître le nombre de fois où vos conditions ont été exécutée :

[source, java]
----
//Déclarations de variables de test
  int nbIterations = 0;
  
  [...]
  
//Dans les conditions :
  nbIterations++;
  
  [...]
  
//Affichage des tests
  System.out.println("Nombre d'itérations : " + nbIterations);
----

==== Analyse
[.text-justify]
Parmi l'ensemble des tests réalisés, le code les passe avec succès sans qu'aucune erreur ne soit à déplorer à la fois sur le résultat attendu mais également sur le code en lui-même.

===== Lisibilité du code - Optionnel
[.text-justify]
Dans son ensemble, le développeur a indiqué certaines caractéristiques précises de son programme, et notamment dans la correspondance entre le caractère espace, et sa valeur en ASCII. +

[.text-justify]
Le code est plutôt épuré, séparant alors les différentes parties (déclarations, conditions, résultats) bien que celui-ci ne soit pas facile à comprendre rapidement, d'où l'absence de javadoc. Mais on comprend rapidement la procédure réalisée par le développeur, à savoir appliquer les traitements de la chaîne de caractère analysée dans une nouvelle chaîne de caractère, qui sera le résultat de la fonction.

===== Qualité du code - Optionnel
[.text-justify]
De ce qui peut être constaté, seul une erreur mineure est à déclarer d'après *Codacy* :

*Erreur mineure :*
____
● Le nom de la classe utilitaire 'Eraser2' ne correspond pas à '[AZ][a-zA-Z0-9]'. +
Autrement dit, cette règle signale les déclarations de type qui ne correspondent pas à la regex qui s'applique à leur genre spécifique.
____

[.text-justify]
De ce fait, bien que cela soit une erreur mineure, le fichier ``efficacite-43.java`` est noté "B" d'après *Codacy*.

image::/rapport/images/efficacite-43.PNG[]

===== Sobriété numérique - Optionnel
✘

===== Efficacité et temps d'exécution
[.text-justify]
L’objectif d’un calcul de complexité algorithmique temporelle est de pouvoir comparer l’efficacité d’algorithmes résolvant le même problème. Dans une situation donnée, cela permet donc d’établir lequel des algorithmes disponibles est le plus optimal. +
Pour ces tests, j'ai procédé à prendre une chaîne de caractères déjà précédemment utilisée (ici "Cou cou  J M  B") et de voir, en la dupliquant, si le temps d'exécution et le nombre d'itérations varient entre-eux (bien que le jeu d'essais soit réalisé sur un très faible échantillon). +

|===
| *Chaînes de caractères analysées* | *Résultat de l'algorithme* | *Résultats attendus* | *Temps d'exécution* | *Nombre d'itérations*

|``'Cou_cou\__J_M__B'`` 
|Test passé ✓ 
|``'Coucou\__JM__B'`` 
|Environ 1 nanoseconde, soit environ 0.000001ms 
|13

|``'\_Cou_cou\__J_M__B_'`` 
|Test passé ✓ 
|``'Coucou\__JM__B'`` 
|Environ 1 nanoseconde, soit environ 0.000001ms 
|13

|``'Cou_cou\__J_M__B'`` (dupliquée 100x) 
|Test passé ✓ 
|``'Coucou\__JM__B'`` (dupliquée 100x) 
|Environ 5 nanosecondes, soit environ 0.000005ms
|1300

|``'Cou_cou\__J_M__B'`` (dupliquée 10000x) 
|Test passé ✓ 
|``Coucou\__JM__B`` (dupliquée 10000x) 
|Environ 162 nanosecondes, soit environ 0.000162ms
|130000

|``'Cou_cou\__J_M__B'`` (dupliquée 100000x) 
|Test passé ✓ 
|``'Coucou\__JM__B'`` (dupliquée 100000x) 
|Environ 752 nanosecondes, soit environ 0.000752ms
|1500000
|===

[.text-justify]
Comme le calcul du nombre d'itérations se fait selon la longueur de la chaîne de caractères mais également des caractères constituant cette même chaîne, il semblerait que la complexité du programme ``efficacite-43.java`` soit de l'ordre de 1 + n(w(x+y)+z) avec :

____
● *n*, le nombre de caractères total ; +
● *w*, le nombre d'espaces ; +
● *x*, le nombre d'espaces *après* un espace ; +
● *y*, le nombre d'espaces *avant* un espace ; +
● Et *z*, le nombre de caractères différents de l'espace.
____

De ce qui concerne la complexité temporelle du programme, une corrélation assez visible s'établit entre la taille de la chaîne de caractères ainsi que le temps d'exécution. Dès lors que cette taille est multipliée par 10 ou par 100 (selon le jeu d'essais précédemment réalisé), le temps d'exécution évolue plus ou moins de la même manière, bien que celui-ci ne soit jamais précis (dû au temps instable du CPU à exécuter le programme, etc). 

Ces deux calculs semblent finalement se ramener à un même point : l'ordre de grandeur de la solution algorithmique ``efficacite-43.java`` est de *O(n)*.

=== Efficacité n°90 (langage Java)

==== Sous-reproductibilité et références

*Utilisation de nanoTime :*

[.text-justify]
L'utilisation de nanoTime est très intéressante. Celle-ci fait partie des méthodes que nous pouvons utiliser depuis l'utilisation générale des affichages à l'écran, aussi connu dans Java sous le nom de *System*.

[.text-justify]
Pour son utilisation, il est donc nécessaire de savoir à partir de quel moment il est intéressant d'évaluer ce temps et jusqu'à quand. Cette évaluation se fera alors pour l'exécution d'une fonction, tout dépendra des répétitions effectuées à son exécution (notamment pour avoir une évaluation précise sur ses temps d'exécution, nécessaires au calcul d'une complexité).

Sur votre ``Main.java``, veuillez ainsi rajouter les lignes de code suivantes :

[source, java]
----
long debut = System.nanoTime();

[...] //Exécution de votre fonction

long fin = System.nanoTime();
System.out.println((fin-debut)/1000000);
----

*Autres :*

[.text-justify]
Il est intéressant de connaître le nombre d'itérations de votre programme, autrement dit, combien de fois est réalisée votre condition en fonction de la chaîne de caractères renseignée. +

[.text-justify]
Pour ce faire, veuillez à déclarer une variable de type entier au début de votre fonction puis, incrémentez cette valeur *au moment où* l'analyse de votre chaîne de caractères avance également et enfin, veuillez retourner votre résultat pour connaître le nombre de fois où vos conditions ont été exécutée :

[source, java]
----
//Déclarations de variables de test
  int nbIterations = 0;
  
  [...]
  
//Dans les conditions :
  nbIterations++;
  
  [...]
  
//Affichage des tests
  System.out.println("Nombre d'itérations : " + nbIterations);
----

==== Analyse
[.text-justify]

===== Lisibilité du code - Optionnel
[.text-justify]

===== Qualité du code - Optionnel
[.text-justify]
A comparer du fichier précédemment analysé (``efficacite-43.java``), celui-ci possède également la même erreur mineure de code à savoir :

*Erreur mineure :*
____
● Le nom de la classe utilitaire 'Eraser' ne correspond pas à '[AZ][a-zA-Z0-9]'. +
Autrement dit, cette règle signale les déclarations de type qui ne correspondent pas à la regex qui s'applique à leur genre spécifique.
____

[.text-justify]
En réalité, bien que le fichier ``efficacite-90.java`` diffère du fait de sa notation par *Codacy* à savoir la notation de "C", cela est en grande partie dû à la complexité mais celle-ci n'est pas une complexité similaire de celle que l'on pourrait calculer comme la complexité temporelle : il s'agit d'une complexité cyclomatique. +
Concrètement, moins il y a de chemins à travers un morceau de code et moins ces chemins sont complexes, plus la complexité cyclomatique est faible. Ces chemins peuvent concerner des déclarations de variables, des sous-conditions, etc. Ici, sa complexité est 2x plus élevée, d'où sa notation plus mauvaise. 

image::/rapport/images/efficacite-90.PNG[]

===== Sobriété numérique - Optionnel
✘

===== Efficacité et temps d'exécution
[.text-justify]

=== Efficacité n°106 (langage Python)

==== Sous-reproductibilité et références

*Module timeit :*

[.text-justify]
timeit est un module permettant de fournir de façon simple le temps d'exécution de fragments de code Python tout en évitant un certain nombre de problèmes classiques liés à la mesure des temps d'exécution.

Pour son importation, veuillez importer ce module en en-tête du code source :

[source, python]
----
import timeit
----
[.text-justify]
Désormais, il vous suffit de l'utiliser. Tout d'abord, veuillez à mettre en commentaire votre fonction et à la stocker dans une variable dont son choix de nom est complètement libre. De là, vous renseignerez directement dans les paramètres de la fonction, la chaîne de caractères que vous souhaiterez analyser. +
Enfin, il vous suffit qu'à reconnaître cette variable et à effectuer des tours de boucle selon votre envie pour en calculer votre temps d'exécution.

Pour l'analyse de cette solution algorithmique, veuillez à reproduire le code suivant :

[source, python]
----
moncode = '''
def erase(s="Cou cou  J M  B"):
    res = ""
    spaces = 0
    
    for c in s:
        if(c is " "): spaces += 1
        else:
            res += " " * spaces + c if spaces > 1 else c
            spaces = 0

    return res + " " * spaces if spaces > 1 else res
'''

print("Temps d'exécution du programme : ",
       timeit.timeit(stmt = moncode,
                     number = 100000
                     ))
----

*Réalisation de tests :*

[.text-justify]
Pour faire que les tests que vous avez posé puissent être réalisés, veuillez ajouter le code suivant tout en haut du fichier ``test.py`` (situé au chemin renseigné ci-dessous et en considérant que le workspace utilisé est celui du *GitHub*) : +

[source, python]
----
import sys
sys.path.append('analyse/Efficacité/Python/efficacite-106')
from efficacite106 import erase
----

[.text-justify]
Il permet de vérifier que le programme traite bien tous les cas donnés. +

*Autres :*

[.text-justify]
Il est intéressant de connaître le nombre d'itérations de votre programme, autrement dit, combien de fois est réalisée votre condition en fonction de la chaîne de caractères renseignée. +

[.text-justify]
Pour ce faire, veuillez à déclarer une variable au début de votre fonction puis, incrémentez cette valeur *au moment où* l'analyse de votre chaîne de caractères avance également et enfin, veuillez retourner votre résultat pour connaître le nombre de fois où vos conditions ont été exécutée :

[source, python]
----
//Déclarations de variables de test
  nbIterations = 0;
  
  [...]
  
//Dans les conditions :
  nbIterations = nbIterations + 1;
  
  [...]
  
//Affichage des tests
  print("Nombre d'itérations ", nbIterations);
----

==== Analyse
[.text-justify]
Parmi l'ensemble des tests réalisés, le code les passe avec succès sans qu'aucune erreur ne soit à déplorer à la fois sur le résultat attendu mais également sur le code en lui-même.

===== Lisibilité du code - Optionnel
[.text-justify]
En réalité, le code n'est pas très intuitif à comprendre. En effet, le réel problème de compréhension à constater dans ce programme, est le fait que certaines conditions (*if* / *else*, etc.) sont affichées à la même ligne d'un résultat affiché. C'est assez perturbant de voir que ces deux éléments soient réalisés sur une même ligne. 

Pour autant, le code est bien réalisé, car on arrive malgré tout à le comprendre bien qu'une absence de commentaire ou de javadoc soit à constater. Il aurait été ainsi préférable, dans un code comme celui-ci, de réellement indiquer les principales ambiguïtés de compréhension qu'un utilisateur lambda pourrait rencontrer.

===== Qualité du code - Optionnel
[.text-justify]
*Codacy* remarque ici-même la présence de quelques erreurs mineures. Les voici :

*Erreurs mineures :*
____
● Espace blanc de fin (ligne vide) ; +
● Préférence à l'utilisation de '== / !=' pour comparer des littéraux constants (str, bytes, int, float, tuple).
____

[.text-justify]
En réalité, il est véridique de dire qu'il soit nécesasire d'ajuster certains points de ce code, pouvant le rendre plus qualitatif et respectueux des différentes règles interposées par *Codacy*. Pour autant, le fichier ``efficacite-106.py`` est noté "C".

image::/rapport/images/efficacite-106.PNG[]

===== Sobriété numérique - Optionnel
✘

===== Efficacité et temps d'exécution
[.text-justify]
Le but visé d’un calcul de complexité algorithmique temporelle est de permettre la comparaison d'une efficacité d’algorithmes résolvant le même problème. Dans une situation donnée, cela permet donc d’établir lequel des algorithmes disponibles est le plus optimal. +
Pour ces tests, j'ai procédé à prendre une chaîne de caractères déjà précédemment utilisée (ici "Cou cou  J M  B") et de voir, en la dupliquant, si le temps d'exécution et le nombre d'itérations varient entre-eux (bien que le jeu d'essais soit réalisé sur un très faible échantillon). +

En voici le tableau adéquat :

|===
| *Chaînes de caractères analysées* | *Résultat de l'algorithme* | *Résultats attendus* | *Temps d'exécution*

|``'Cou_cou\__J_M__B'`` 
|Test passé ✓ 
|``'Coucou\__JM__B'`` 
|Environ 6*10^-7 soit 0.0000006s ou 0.0006ms

|``'\_Cou_cou\__J_M__B_'`` 
|Test passé ✓
|``'Coucou\__JM__B'`` 
|Environ 6*10^-7 soit 0.0000006s ou 0.0006ms

|``'Cou_cou\__J_M__B'`` (dupliquée 100x) 
|Test passé ✓ 
|``'Coucou\__JM__B'`` (dupliquée 100x) 
|Environ 1.21*10^-5 soit 0.0000121s ou 0.0121ms

|``'Cou_cou\__J_M__B'`` (dupliquée 10000x) 
|Test passé ✓ 
|``Coucou\__JM__B`` (dupliquée 10000x) 
|Environ 0.0011096s, soit 1.1096ms

|``'Cou_cou\__J_M__B'`` (dupliquée 100000x) 
|Test passé ✓ 
|``'Coucou\__JM__B'`` (dupliquée 100000x) 
|Environ 0.0114697s, soit 11.4697ms
|===

[.text-justify]
En ce qui concerne l’efficacité, si on traite une chaîne de caractères 10 fois ou 100 fois plus grande, le temps de calcul sera approximativement multiplié de la même manière. De ce fait, pour une complexité temporelle ici, il s'agit d'un ordre de grandeur de *O(n)*.

=== Efficacité n°131 (langage Java)

==== Sous-reproductibilité et références

*Utilisation de nanoTime :*

[.text-justify]
L'utilisation de nanoTime est très intéressante. Celle-ci fait partie des méthodes que nous pouvons utiliser depuis l'utilisation générale des affichages à l'écran, aussi connu dans Java sous le nom de *System*.

[.text-justify]
Pour son utilisation, il est donc nécessaire de savoir à partir de quel moment il est intéressant d'évaluer ce temps et jusqu'à quand. Cette évaluation se fera alors pour l'exécution d'une fonction, tout dépendra des répétitions effectuées à son exécution (notamment pour avoir une évaluation précise sur ses temps d'exécution, nécessaires au calcul d'une complexité).

Sur votre ``Main.java``, veuillez ainsi rajouter les lignes de code suivantes :

[source, java]
----
long debut = System.nanoTime();

[...] //Exécution de votre fonction

long fin = System.nanoTime();
System.out.println((fin-debut)/1000000);
----

*Autres :*

[.text-justify]
Il est intéressant de connaître le nombre d'itérations de votre programme, autrement dit, combien de fois est réalisée votre condition en fonction de la chaîne de caractères renseignée. +

[.text-justify]
Pour ce faire, veuillez à déclarer une variable de type entier au début de votre fonction puis, incrémentez cette valeur *au moment où* l'analyse de votre chaîne de caractères avance également et enfin, veuillez retourner votre résultat pour connaître le nombre de fois où vos conditions ont été exécutée :

[source, java]
----
//Déclarations de variables de test
  int nbIterations = 0;
  
  [...]
  
//Dans les conditions :
  nbIterations++;
  
  [...]
  
//Affichage des tests
  System.out.println("Nombre d'itérations : " + nbIterations);
----

==== Analyse
[.text-justify]
Dès lors de l'import de la solution algorithmique ``efficacite-131.java``, une erreur de compilation est à constater. En effet, quel que soit le test réalisé depuis la classe ``EraserTest.java``, impossible d'exécuter le programme. +
Cette erreur de compilation est ici, due à une duplication (sans doute) involontaire de la variable *i*. Bien que l'erreur soit minime, il est malheureux de constater que le programme ne marche pas.

===== Lisibilité du code - Optionnel
[.text-justify]
Le code est très peu lisible. En effet, il est ici, impossible à ce qu'un utilisateur lambda puisse imaginer que le code ASCII du caractère espace soit 32 (sauf pour les adeptes de l'informatique) et n'ayant aucun commentaire réalisé de la part de ce développeur, il est en réalité difficile de discerner le fonctionnement de ce programme. L'absence ainsi de javadoc est également à constater. +

Pour autant, à comparer de l'ensemble des programmes, tout n'est pas à rejeter car le développeur a utilisé ici, une classe très intéressante : StringBuilder. +
De même, il est difficile d'imaginer ce à quoi pourrait correspondre cette classe mais en réalité, elle représente une chaîne de caractères mutable.

===== Qualité du code - Optionnel
[.text-justify]
Le fichier ``efficacite-131.java`` est *le* fichier le plus mauvais en terme de qualité d'après *Codacy*. Bien qu'une erreur mineure soit alors à constater (et déjà présente dans certains des fichiers précédemment analysés), deux erreurs moyennes sont tout de même à déplorer. Les voici :

*Erreur mineure :*
____
● Le nom de la classe utilitaire 'Eraser' ne correspond pas à '[AZ][a-zA-Z0-9]'. +
Autrement dit, cette règle signale les déclarations de type qui ne correspondent pas à la regex qui s'applique à leur genre spécifique.
____

*Erreurs moyennes :*
____
● Préférence d'éviter les variables locales inutilisées telles que 'i' ; +
● Le fait d'éviter de réaffecter des paramètres tels que 'str'.
____

Sans contestation possible, le fichier ``efficacite-131.java`` est non-seulement le pire en terme de qualité, mais il est également noté "F" par *Codacy*, chose plutôt compréhensible.

image::/rapport/images/efficacite-131.PNG[]

===== Sobriété numérique - Optionnel
✘

===== Efficacité et temps d'exécution
[.text-justify]
Du fait d'avoir un fichier ne compilant pas, il devient rapidement compliqué d'en évaluer sa complexité temporelle pour en déterminer un certain ordre de grandeur. 

== Catégorie "Simplicité"

=== Simplicité n°11 (langage Java)

==== Sous-reproductibilité et références

*Utilisation de nanoTime :*

[.text-justify]
L'utilisation de nanoTime est très intéressante. Celle-ci fait partie des méthodes que nous pouvons utiliser depuis l'utilisation générale des affichages à l'écran, aussi connu dans Java sous le nom de *System*.

[.text-justify]
Pour son utilisation, il est donc nécessaire de savoir à partir de quel moment il est intéressant d'évaluer ce temps et jusqu'à quand. Cette évaluation se fera alors pour l'exécution d'une fonction, tout dépendra des répétitions effectuées à son exécution (notamment pour avoir une évaluation précise sur ses temps d'exécution, nécessaires au calcul d'une complexité).

Sur votre ``Main.java``, veuillez ainsi rajouter les lignes de code suivantes :

[source, java]
----
long debut = System.nanoTime();

[...] //Exécution de votre fonction

long fin = System.nanoTime();
System.out.println((fin-debut)/1000000);
----

*Autres :*

[.text-justify]
Il est intéressant de connaître le nombre d'itérations de votre programme, autrement dit, combien de fois est réalisée votre condition en fonction de la chaîne de caractères renseignée. +

[.text-justify]
Pour ce faire, veuillez à déclarer une variable de type entier au début de votre fonction puis, incrémentez cette valeur *au moment où* l'analyse de votre chaîne de caractères avance également et enfin, veuillez retourner votre résultat pour connaître le nombre de fois où vos conditions ont été exécutée :

[source, java]
----
//Déclarations de variables de test
  int nbIterations = 0;
  
  [...]
  
//Dans les conditions :
  nbIterations++;
  
  [...]
  
//Affichage des tests
  System.out.println("Nombre d'itérations : " + nbIterations);
----

==== Analyse
[.text-justify]
Parmi l'ensemble des tests réalisés, le code les passe avec succès sans qu'aucune erreur ne soit à déplorer à la fois sur le résultat attendu mais également sur le code en lui-même.

===== Lisibilité du code
[.text-justify]
Bien que beaucoup de conditions soient réalisées au sein de la solution algorithmique ``simplicite-11.java``, celui-ci reste pour autant assez compréhensible. Le développeur a décidé de mettre dans un tableau, chaque caractère séparé de la chaîne de caractères analysée. + 
De ce tableau parcouru, il crée une nouvelle chaîne de caractères qui prendra en considération les modifications et les conditions à respecter.  

Il vérifie ainsi la taille de la chaîne de caractères ainsi que des caractères présents au sein de la chaîne de caractères renseignée dans différentes conditions, pour bien comprendre comment l'analyse se fait, étape par étape. Très peu de remarques sont alors à constater.+

Pour autant, comme de nombreux codes, celui-ci ne possède pas de javadocs et n'est donc pas instructif au premier abord. Mais on peut le comprendre assez rapidement, quelle que soit la personne.

===== Qualité du code
[.text-justify]
De ce qui peut être constaté, quelques erreurs mineurs ainsi qu'une erreur moyenne sont à constater sur cette solution algorithmique par *Codacy* : +

*Erreurs mineures :*
____
● Le nom de la classe utilitaire 'Erase1' ne correspond pas à '[AZ][a-zA-Z0-9]' ; +
Concrètement, comme déjà mentionné auparavant, il s'agit d'un non-respect de convention de dénomination configurables pour les déclarations de type. Elle signale les déclarations de type qui ne correspondent pas à la regex qui s'applique à leur genre spécifique ; +
● Toutes les classes, interfaces, énumérations et annotations doivent appartenir à un package nommé, chose ici non-présente. +
____

*Erreur moyenne :*
____
● La méthode 'erase1(String)' a une complexité NPath (nombre de chemins acycliques) de 384, le seuil actuel est de 200. +
Cette complexité NPath correspond au nombre de chemins d'exécution acycliques à travers cette méthode, étant alors des chemins complets du début à la fin du bloc de la méthode. Ainsi, cette métrique croît de manière exponentielle, car elle multiplie la complexité des instructions dans le même bloc. +
Le seuil recommandé par Codacy est de 200 car il est considéré comme étant le point où des mesures doivent être prises pour réduire la complexité et augmenter la lisibilité.
____

Ainsi, bien que le code reste pour autant assez qualitatif, *Codacy* note le fichier ``simplicite-11.java`` "B".

image::/rapport/images/simplicite-11.PNG[]

===== Sobriété numérique - Optionnel
✘ 

===== Efficacité et temps d'exécution - Optionnel
[.text-justify]
Le calcul d'une complexité se réalise selon deux critères : L'efficacité (ici, la taille d'une chaîne de caractères) ainsi que le temps d'exécution. +
Pour ces tests, j'ai procédé à prendre une chaîne de caractères déjà précédemment utilisée (ici "Cou cou  J M  B") et de voir, en la dupliquant, si le temps d'exécution et le nombre d'itérations varient. +

|===
| *Chaînes de caractères analysées* | *Résultat de l'algorithme* | *Résultats attendus* | *Temps d'exécution* | *Nombre d'itérations*

|``'Cou_cou\__J_M__B'`` 
|Test passé ✓ 
|``'Coucou\__JM__B'`` 
|Environ 1 nanoseconde, soit environ 0.000002ms 
|15

|``'\_Cou_cou\__J_M__B_'`` 
|Test passé ✓ 
|``'Coucou\__JM__B'`` 
|Environ 1 nanoseconde, soit environ 0.000002ms 
|17

|``'Cou_cou\__J_M__B'`` (dupliquée 100x) 
|Test passé ✓ 
|``'Coucou\__JM__B'`` (dupliquée 100x) 
|Environ 11 nanosecondes, soit environ 0.0000011ms
|1500

|``'Cou_cou\__J_M__B'`` (dupliquée 10000x) 
|Test passé ✓ 
|``Coucou\__JM__B`` (dupliquée 10000x) 
|Environ 177 nanosecondes, soit environ 0.000177ms
|150000

|``'Cou_cou\__J_M__B'`` (dupliquée 100000x) 
|Test passé ✓ 
|``'Coucou\__JM__B'`` (dupliquée 100000x) 
|Environ 721 nanosecondes, soit environ 0.000721ms
|1500000
|===

[.text-justify]
En ce qui concerne l’efficacité, le temps d'exécution dépend de l'évolutivité de la taille de la chaîne de caractères. Ainsi, dès lors que la taille est augmentée (ici par 10x), le temps d'exécution suit d'une manière approximative, cette même opération bien que cela ne soit jamais bien précis. Pour une complexité temporelle ici, il s'agit d'un ordre de grandeur de *O(n)*.

=== Simplicité n°39 (langage Java)

==== Sous-reproductibilité et références

*Utilisation de nanoTime :*

[.text-justify]
L'utilisation de nanoTime est très intéressante. Celle-ci fait partie des méthodes que nous pouvons utiliser depuis l'utilisation générale des affichages à l'écran, aussi connu dans Java sous le nom de *System*.

[.text-justify]
Pour son utilisation, il est donc nécessaire de savoir à partir de quel moment il est intéressant d'évaluer ce temps et jusqu'à quand. Cette évaluation se fera alors pour l'exécution d'une fonction, tout dépendra des répétitions effectuées à son exécution (notamment pour avoir une évaluation précise sur ses temps d'exécution, nécessaires au calcul d'une complexité).

Sur votre ``Main.java``, veuillez ainsi rajouter les lignes de code suivantes :

[source, java]
----
long debut = System.nanoTime();

[...] //Exécution de votre fonction

long fin = System.nanoTime();
System.out.println((fin-debut)/1000000);
----

*Autres :*

[.text-justify]
Il est intéressant de connaître le nombre d'itérations de votre programme, autrement dit, combien de fois est réalisée votre condition en fonction de la chaîne de caractères renseignée. +

[.text-justify]
Pour ce faire, veuillez à déclarer une variable de type entier au début de votre fonction puis, incrémentez cette valeur *au moment où* l'analyse de votre chaîne de caractères avance également et enfin, veuillez retourner votre résultat pour connaître le nombre de fois où vos conditions ont été exécutée :

[source, java]
----
//Déclarations de variables de test
  int nbIterations = 0;
  
  [...]
  
//Dans les conditions :
  nbIterations++;
  
  [...]
  
//Affichage des tests
  System.out.println("Nombre d'itérations : " + nbIterations);
----

==== Analyse
[.text-justify]
Parmi l'ensemble des tests réalisés, le code les passe avec succès sans qu'aucune erreur ne soit à déplorer à la fois sur le résultat attendu mais également sur le code en lui-même.

===== Lisibilité du code
[.text-justify]
A la différence du fichier précédemment analysé (``simplicite-11.java``), la solution algorithmique ``simplicite-39.java`` adopte une méthode différente et notamment dans les conditions réalisées. Ici, les changements apportés sur la chaîne de caractères analysée se réalise directement sur celle-ci du moment que la chaîne de caractères ne contient pas d'espaces. Sinon, les changements s'effectuent de même sur une nouvelle chaîne de caractères, dépendante de celle analysée. +

Les conditions effectuées donc, diffèrent également mais sont bien moins compréhensibles, quand on sait qu'un espace a pour valeur ASCII "32". +
Les conditions sont également empilées, c'est-à-dire que tout dépend d'une condition externe, étant le fait de savoir si le message contient ou non des espaces. De ce fait, on rentre dans des conditions encore plus profondes afin d'en arriver à une condition terminale indiquant si un espace est présent à l'indice i. +

Néanmoins, le code peut être simplifié, puisque le développeur utilise à de rares occasions les expressions conditionnelles (``&&`` pour *ET*, ``||`` pour *OU*, etc.), empilant alors des *if* dans des *if*. +

Enfin, une dernière remarque assez commune à tous est l'absence de javadoc, n'étant pas directement compréhensible par un utilisateur lambda.

===== Qualité du code
[.text-justify]
Il semblerait qu'aucune erreur ne soit à constater sur cette solution algorithmique. Il paraît alors être le plus qualitatif des autres. +
D'après *Codacy*, le fichier ``simplicite-39.java`` est noté "A".

image::/rapport/images/simplicite-39.PNG[]

===== Sobriété numérique - Optionnel
✘

===== Efficacité et temps d'exécution - Optionnel
[.text-justify]
Deux critères sont essentiels au calcul d'une complexité : L'efficacité ainsi que le temps d'exécution. +
Pour ces tests, j'ai procédé à prendre une chaîne de caractères déjà précédemment utilisée (ici "Cou cou  J M  B") et de voir, en la dupliquant, si le temps d'exécution et le nombre d'itérations varient. +

|===
| *Chaînes de caractères analysées* | *Résultat de l'algorithme* | *Résultats attendus* | *Temps d'exécution*

|``'Cou_cou\__J_M__B'`` 
|Test passé ✓ 
|``'Coucou\__JM__B'`` 
|- d'une nanoseconde 

|``'\_Cou_cou\__J_M__B_'`` 
|Test passé ✓ 
|``'Coucou\__JM__B'`` 
|- d'une nanoseconde 

|``'Cou_cou\__J_M__B'`` (dupliquée 100x) 
|Test passé ✓ 
|``'Coucou\__JM__B'`` (dupliquée 100x) 
|Environ 2 nanosecondes, soit environ 0.000002ms

|``'Cou_cou\__J_M__B'`` (dupliquée 10000x) 
|Test passé ✓ 
|``Coucou\__JM__B`` (dupliquée 10000x) 
|Environ 50 nanosecondes, soit environ 0.000050ms

|``'Cou_cou\__J_M__B'`` (dupliquée 100000x) 
|Test passé ✓ 
|``'Coucou\__JM__B'`` (dupliquée 100000x) 
|Environ 155 nanosecondes, soit environ 0.000155ms
|===

[.text-justify]
Le temps d'exécution dépend de l'évolutivité de la taille de la chaîne de caractères. Cet algorithme est très intéressant à analyser car dès lors que la taille de la chaîne de caractères augmente (ici 10x), le temps d'exécution semble être moins important, en réalité étant lui-même multiplié aux alentours de 5x. Ainsi, le temps n'étant pas corrélé de la même manière que la taille de la chaîne de caractères, il semblerait que la courbe réalisée semble davantage suivre la tendance pour un ordre de grandeur de *O(log(n))*, bien qu'incertain de ce qui puisse être constaté.

=== Simplicité n°56 (langage Java)

==== Sous-reproductibilité et références

*Utilisation de nanoTime :*

[.text-justify]
L'utilisation de nanoTime est très intéressante. Celle-ci fait partie des méthodes que nous pouvons utiliser depuis l'utilisation générale des affichages à l'écran, aussi connu dans Java sous le nom de *System*.

[.text-justify]
Pour son utilisation, il est donc nécessaire de savoir à partir de quel moment il est intéressant d'évaluer ce temps et jusqu'à quand. Cette évaluation se fera alors pour l'exécution d'une fonction, tout dépendra des répétitions effectuées à son exécution (notamment pour avoir une évaluation précise sur ses temps d'exécution, nécessaires au calcul d'une complexité).

Sur votre ``Main.java``, veuillez ainsi rajouter les lignes de code suivantes :

[source, java]
----
long debut = System.nanoTime();

[...] //Exécution de votre fonction

long fin = System.nanoTime();
System.out.println((fin-debut)/1000000);
----

*Autres :*

[.text-justify]
Il est intéressant de connaître le nombre d'itérations de votre programme, autrement dit, combien de fois est réalisée votre condition en fonction de la chaîne de caractères renseignée. +

[.text-justify]
Pour ce faire, veuillez à déclarer une variable de type entier au début de votre fonction puis, incrémentez cette valeur *au moment où* l'analyse de votre chaîne de caractères avance également et enfin, veuillez retourner votre résultat pour connaître le nombre de fois où vos conditions ont été exécutée :

[source, java]
----
//Déclarations de variables de test
  int nbIterations = 0;
  
  [...]
  
//Dans les conditions :
  nbIterations++;
  
  [...]
  
//Affichage des tests
  System.out.println("Nombre d'itérations : " + nbIterations);
----

==== Analyse
[.text-justify]
Parmi l'ensemble des tests réalisés, le code les passe avec succès sans qu'aucune erreur ne soit à déplorer à la fois sur le résultat attendu mais également sur le code en lui-même.

===== Lisibilité du code
[.text-justify]
Sans doute l'un des codes les plus agréables à regarder, la solution algorithmique ``simplicite-56.java`` possède une lisibilité très agréable. +
En effet, le développeur a fait un effort de séparer les parties *déclarations de variables* et *création de la chaîne de caractères* en détaillant les procédures réalisées (pourquoi telle variable, que fait telle condition, etc.)

Ainsi, bien que l'on regarde en détails les conditions réalisées par le développeur, tout est déjà détaillé, ce qui permet une bien meilleure compréhension du code. On comprend alors rapidement qu'il effectue les vérifications dans une nouvelle chaîne de caractères, en utilisant également également une variable *'espace'*, indispensable pour calculer le nombre d'espaces et donc,  d'effectuer les changements selon ce nombre en question. +

Un léger problème est à déclarer : l'oubli de la javadoc pour la descritpion de la fonction. En regardant les commentaires, on se rend assez rapidement compte de ce qu'il est effectué mais nous devons l'observer dans l'en-tête de celle-ci, sans rentrer dans les détails.

===== Qualité du code
[.text-justify]
A en suivre l'analyse réalisée par *Codacy*, il semblerait que quelques erreurs soient à constater, aussi bien mineures que moyennes. Les voici :

*Erreur mineure :*
____
● Le nom de la classe utilitaire 'Eraser' ne correspond pas à '[AZ][a-zA-Z0-9]'. +
Cette erreur paraît commune à beaucoup de code à analyser. Il s'agit, comme déjà mentionné, d'un non-respect de convention de dénomination configurables pour les déclarations de type. Elle signale les déclarations de type qui ne correspondent pas à la regex qui s'applique à leur genre spécifique ; +
____

*Erreur moyenne :*
____
● Des instructions if sont imbriquées et pourraient être combinées.
____

Il semble alors que le code présente de la redondance dans certaines conditions, que l'on pourrait condenser et donc, simplifier. De ce fait, l'algorithme serait plus qualitatif et ne présenterait aucune condition de trop, ou supplémentaire que l'on peut alors ajuster.

Néanmoins, d'après *Codacy*, le fichier ``simplicite-56.java`` est noté "B".

image::/rapport/images/simplicite-56.PNG[]

===== Sobriété numérique - Optionnel
✘

===== Efficacité et temps d'exécution - Optionnel
[.text-justify]
L'efficacité ainsi que le temps d'exécution de la solution algorithmique sont nécessaires à un calcul de complexité. +
Pour ces tests, j'ai procédé à prendre une chaîne de caractères déjà précédemment utilisée (ici "Cou cou  J M  B") et de voir, en la dupliquant, si le temps d'exécution et le nombre d'itérations varient. +

En voici le tableau adéquat :

|===
| *Chaînes de caractères analysées* | *Résultat de l'algorithme* | *Résultats attendus* | *Temps d'exécution* | *Nombre d'itérations*

|``'Cou_cou\__J_M__B'`` 
|Test passé ✓ 
|``'Coucou\__JM__B'`` 
|Environ une nanoseconde, soit environ 0.000001ms
|13

|``'\_Cou_cou\__J_M__B_'`` 
|Test passé ✓ 
|``'Coucou\__JM__B'`` 
|Environ une nanoseconde, soit environ 0.000001ms
|13

|``'Cou_cou\__J_M__B'`` (dupliquée 100x) 
|Test passé ✓ 
|``'Coucou\__JM__B'`` (dupliquée 100x) 
|Environ 5 nanosecondes, soit 0.000005ms
|1300

|``'Cou_cou\__J_M__B'`` (dupliquée 10000x) 
|Test passé ✓ 
|``Coucou\__JM__B`` (dupliquée 10000x) 
|Environ 155 nanosecondes, soit 0.0000155ms
|13000

|``'Cou_cou\__J_M__B'`` (dupliquée 100000x) 
|Test passé ✓ 
|``'Coucou\__JM__B'`` (dupliquée 100000x) 
|Environ 842 nanosecondes, soit 0.000842ms
|130000
|===

[.text-justify]
Comme la plupart des algorithmes présentés, en ce qui concerne l’efficacité, le temps d'exécution dépend de l'évolutivité de la taille de la chaîne de caractères. Ainsi, dès lors que la taille est augmentée (ici par 10x), le temps d'exécution suit d'une manière approximative, cette même opération bien que cela ne soit jamais bien précis. Pour une complexité temporelle ici, il s'agit d'un ordre de grandeur de *O(n)*.

=== Simplicité n°71 (langage Java)

==== Sous-reproductibilité et références

*Utilisation de nanoTime :*

[.text-justify]
L'utilisation de nanoTime est très intéressante. Celle-ci fait partie des méthodes que nous pouvons utiliser depuis l'utilisation générale des affichages à l'écran, aussi connu dans Java sous le nom de *System*.

[.text-justify]
Pour son utilisation, il est donc nécessaire de savoir à partir de quel moment il est intéressant d'évaluer ce temps et jusqu'à quand. Cette évaluation se fera alors pour l'exécution d'une fonction, tout dépendra des répétitions effectuées à son exécution (notamment pour avoir une évaluation précise sur ses temps d'exécution, nécessaires au calcul d'une complexité).

Sur votre ``Main.java``, veuillez ainsi rajouter les lignes de code suivantes :

[source, java]
----
long debut = System.nanoTime();

[...] //Exécution de votre fonction

long fin = System.nanoTime();
System.out.println((fin-debut)/1000000);
----

*Autres :*

[.text-justify]
Il est intéressant de connaître le nombre d'itérations de votre programme, autrement dit, combien de fois est réalisée votre condition en fonction de la chaîne de caractères renseignée. +

[.text-justify]
Pour ce faire, veuillez à déclarer une variable de type entier au début de votre fonction puis, incrémentez cette valeur *au moment où* l'analyse de votre chaîne de caractères avance également et enfin, veuillez retourner votre résultat pour connaître le nombre de fois où vos conditions ont été exécutée :

[source, java]
----
//Déclarations de variables de test
  int nbIterations = 0;
  
  [...]
  
//Dans les conditions :
  nbIterations++;
  
  [...]
  
//Affichage des tests
  System.out.println("Nombre d'itérations : " + nbIterations);
----

==== Analyse
[.text-justify]
Parmi l'ensemble des tests réalisés, le code les passe avec succès ou presque. En effet, le résultat attendu est, pour la majorité des chaînes de caractères renseignées, correct mais pour des chaînes commençant ou terminant par un espace, le programme retourne une erreur car la limitation de la taille de la chaîne de caractères ou simplement le premier caractère, chose qui n'a pas été traité.

===== Lisibilité du code
[.text-justify]
Sur cette solution algorithmique, prénommée par le fichier ``simplicite-71.java``, sa lisibilité de code est très correcte. Peu de lignes de codes ont également été réalisée avec des conditions de vérification très concises et simples à comprendre. +
Il n'est également pas compact, ce qui reste agréable à regarder. Ici, l'utilisateur a choisi de créer une nouvelle chaîne de caractères dans laquelle l'ensemble des traitements effectués depuis la chaîne renseignée seront réalisés dans cette nouvelle chaîne déclarée dans cette fonction. 

Pour autant, l'absence de javadoc est constatée, ce qui aurait pu permettre d'avoir une meilleure compréhension et une meilleure approche sur la fonctionnalité implémentée par le développeur.

===== Qualité du code
[.text-justify]
Enfin, pour ce dernier fichier à analyser, *Codacy* montre une nouvelle fois, la même erreur mineure que déjà constatée auparavant :

*Erreur mineure :*
____
● Le nom de la classe utilitaire 'Eraser' ne correspond pas à '[AZ][a-zA-Z0-9]'. +
Il s'agit d'un non-respect de convention de dénomination configurables pour les déclarations de type. Elle signale les déclarations de type qui ne correspondent pas à la regex qui s'applique à leur genre spécifique. +
____

Bien que ce soit la seule soi-disante "erreur" à constater, *Codacy* a attribué la note de "B" au fichier ``simplicite-71.java``.

image::/rapport/images/simplicite-71.PNG[]

===== Sobriété numérique - Optionnel
✘

===== Efficacité et temps d'exécution - Optionnel
[.text-justify]
Pour alors évaluer l'efficacité et le temps d'exécution de la solution algorithmique, un ensemble de tests est alors réalisé. +
Pour ces tests, j'ai procédé à prendre une chaîne de caractères déjà précédemment utilisée (ici "Cou cou  J M  B") et de voir, en la dupliquant, si le temps d'exécution et le nombre d'itérations varient. +

En voici le tableau adéquat :

|===
| *Chaînes de caractères analysées* | *Résultat de l'algorithme* | *Résultats attendus* | *Temps d'exécution* | *Nombre d'itérations*

|``'Cou_cou\__J_M__B'`` 
|Test passé ✓ 
|``'Coucou\__JM__B'`` 
|Environ une nanoseconde, soit environ 0.000001ms
|13

|``'\_Cou_cou\__J_M__B_'`` 
|Test invalide ✘ 
|``'Coucou\__JM__B'`` 
|String index out of range: -1 
|String index out of range: -1

|``'Cou_cou\__J_M__B'`` (dupliquée 100x) 
|Test passé ✓ 
|``'Coucou\__JM__B'`` (dupliquée 100x) 
|Environ 6 nanosecondes, soit 0.000006ms
|1300

|``'Cou_cou\__J_M__B'`` (dupliquée 10000x) 
|Test passé ✓ 
|``Coucou\__JM__B`` (dupliquée 10000x) 
|Environ 118 nanosecondes, soit 0.0000118ms
|13000

|``'Cou_cou\__J_M__B'`` (dupliquée 100000x) 
|Test passé ✓ 
|``'Coucou\__JM__B'`` (dupliquée 100000x) 
|Environ 685 nanosecondes, soit 0.000685ms
|130000
|===

Comme déjà mentionné précédemment, tous les tests à effectuer ne passent pas. Ici, la gestion des conditions posent plusieurs problèmes car en voulant vérifier le caractère précédent ou suivant, celui-ci risque très fortement sortir de la limite de taille de la chaîne de caractères ce qui deviendra problématique.

Pour autant, en fonction de la longueur de la chaîne de caractères, son temps d'exécution augmente également bien qu'il semble peu corrélé en fonction de la longueur de la chaîne de caractères. +
En ce qui concerne l’efficacité, le nombre de tours effectué dépend de la taille du texte analysé. Pour une complexité se basant sur un nombre d'itérations ici, il s'agit d'un ordre de grandeur de O(n).

== Classement

Voici donc le classement final selon les catégories :

|===
|Catégorie |Solution algorithmique |Lisibilité |Qualité |Temps d'exécution |Efficacité |Sobriété |Position |Notation

.4+<.>|Simplicité
|``simplicite-11.java``
|C
|C
|✘
|✘
|✘
|3ème
|3/5

|``simplicite-39.java``
|D
|A
|✘
|✘
|✘
|1er
|5/5

|``simplicite-56.java``
|A
|D
|✘
|✘
|✘
|1er
|5/5

|``simplicite-71.java``
|B
|B
|✘
|✘
|✘
|4ème
|1/5

.4+<.>|Efficacité
|``efficacite-43.java``
|✘
|✘
|
|
|✘
|
|

|``efficacite-90.java``
|✘
|✘
|
|
|✘
|
|

|``efficacite-106.py``
|✘
|✘
|
|
|✘
|
|

|``efficacite-131.java``
|✘
|✘
|
|
|✘
|
|

.3+<.>|Sobriété
|``sobriete-57.c``
|✘
|✘
|C
|✘
|A
|1er
|5/5

|``sobriete-162.py``
|✘
|✘
|A
|✘
|D
|2nd
|4/5

|``sobriete-166.c``
|✘
|✘
|B
|✘
|B
|3ème
|1/5
|===

== Exemple de code

=== Efficacité n°21 (python)

===== Efficacité et temps d'exécution
[.text-justify]
Les temps d'exécutions analysés via le programme ``analyse.py`` semblent être inconstants. La complexité du programme ``efficacite21`` dépend du nombre d'espace dans la chaîne donnée. Cette dernière semble se rapprocher le plus de *O(2n)*.
