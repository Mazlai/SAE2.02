:toc:
:toc-placement!:
:toc-title: Table des matières
:sectnums:

image::/rapport/images/logo_transparent.png[]

= SAE 2.02 - Comparaison d'approches algorithmiques

_Réalisé par FERNANDEZ Mickael (4A)_

toc::[]

== Objectif

[.text-justify]
Parmi l'ensemble des solutions algorithmiques proposées, il est nécessaire de les explorer en ayant une approche s'intéressant à l'implémentation bas niveau (structures de données, etc.) ainsi qu'à haut niveau (précision des résultats, etc.)

[NOTE]
[.text-justify]
Les solutions algorithmiques sont des fichiers de divers langages (C, Python, Java) dont le but était de seulement retirer les espaces individuels, qu'importe de l'emplacement de ceux-ci.

*NOTATION*

En voici la grille de notation :

|===
|*Cas*|*Points*
|Ne compile/s'exécute pas|0
|Ne passe pas les tests fournis ou a rate certains cas|1
|Meilleur algo de la catégorie|5
|2nd algo|4
|3e algo|3
|4e algo|2
|===
En cas d'ex-aequo, même note. (5/5/3/2 par exemple).

== Prérequis
Plusieurs prérequis ont alors été nécessaire à la réalisation de l'ensemble des analyses des fichiers :
____
*En C :* +
● Un compilateur *GCC* en langage C sous Windows ; +
● Un IDE (ici, CodeBlocks était utilisé pour le temps d'exécution sur le fichier ``sobriete-57.c``). +

*En Java :* +
● Un IDE (ici Eclipse, bien que vous puissiez en choisir un autre). +

*En Python :*
____

== Reproductibilité et références
[.text-justify]
*Compilateur GCC :*

[.text-justify]
Pour l'utilisation du compilateur *GCC* dans votre terminal, je vous invite à installer la plate-forme de distribution et de construction de logiciels pour Windows *MSYS2* en http://feaforall.com/install-c-language-gcc-compiler-windows/[__cliquant ici__]. L'ensemble des étapes d'installation seront indiquées. +

[.text-justify]
Bien qu'il soit aisé d'installer facilement l'ensemble des packages nécessaires, il est également intéressant de savoir comment utiliser le compilateur *GCC* directement depuis votre terminal Windows : il est alors nécessaire que vous ajoutiez vos exécutables à votre PATH Windows. +

[.text-justify]
La procédure à suivre vous est proposée en bas de page sur l'article http://feaforall.com/install-c-language-gcc-compiler-windows/[__suivant__].

*CodeBlocks :*

[.text-justify]
CodeBlocks ne nécessite pas de configuration particulière pour pouvoir compiler et exécuter un programme, ici en C. L'avantage de son utilisation est que le temps d'exécution est automatiquement calculé. Ainsi, pour paramétrer votre fichier ``sobriete-57.c``, il est d'abord nécessaire de l'installer. Pour toutes ces étapes, il suffit de :
____
● Se rendre sur le site de https://www.codeblocks.org/downloads/[__Code::Blocks__] et aller dans la section "Downloads" puis "Download the binary release" ; +
● Paramétrez alors votre logiciel CodeBlocks selon vos préférences ; +
● Une fois CodeBlocks d'ouvert, sélectionnez "File" > "Open..." et enfin, trouvez votre fichier ; +
● Exécutez votre code.
____

*Eclipse :*

Eclipse est un IDE qui ne nécessite pas de configuration particulière pour l'exécuter. Tout de même, pour exécuter en revanche un fichier Java, il est nécessaire de définir son environnement de travail et de paramétrer certaines fonctionnalités.

Tout d'abord, rendez-vous sur le site d'https://www.eclipse.org/downloads/[__Eclipse__] et télécharger la version recommandée. Vous définirez alors votre chemin pour savoir d'où vous pourrez exécuter Eclipse et vous paramétrez cet IDE comme bon vous semble.

Pour l'analyse de cette solution algorithmique, il est d'abord nécessaire d'avoir un environnement de travail (workspace). Vous pouvez tout simplement en créer un.
De là, vous n'avez qu'à vous rendre sur la https://github.com/IUT-Blagnac/sae2-02-Mazlai[__page principale__] de cette SAÉ sur GitHub, et de cliquer sur "Code" > "Download ZIP". De là, vous n'avez qu'à extraire celui-ci. 

Vous créez alors un nouveau projet du nom que vous souhaitez, et dans le dossier "src", vous n'avez qu'à glisser les packages déjà présents dans le zip à savoir : +

____
● main.java.eraser ; +
● test.java
____

WARNING: Il se peut que vous ayez une erreur de buildpath ou que vous n'ayez pas de JUnit paramétré.

● _Si vous avez une erreur de buildpath :_

→ Faites un clic droit sur le projet que vous avez précédemment créé et allez dans "Properties" > "Java Build Path" > "Librairies". +
→ De ce fait, cliquez sur "Modulepath" > "Add Library" > "JRE System Library" > "Workspace default JRE". Et enfin, terminez. Vous cliquerez pour terminer sur "Apply and close". +
→ Vous cliquerez alors sur "Order and Export" et sélectionnerez le nouveau JRE que vous avez ajouté. 

● _Si vous avez une erreur de JUnit :_

→ Faites un clic droit sur le projet que vous avez précédemment créé et allez dans "Properties" > "Java Build Path" > "Librairies". +
→ De ce fait, cliquez sur "Classpath" > "Add External JARs..." et vous naviguerez pour trouver votre JUnit. En règle générale, il se situera dans "Java" > "Eclipse" > "Plugins" > "org.junit_[votre version]". Enfin, vous cliquerez sur "Apply and close". +
→ Vous cliquerez alors sur "Order and Export" et sélectionnerez le nouveau JAR que vous avez ajouté.

== Catégorie "Sobriété"

=== Sobriété n°57 (langage C)

==== Sous-reproductibilité et références

*Autres :*

[.text-justify]
Enfin, il en va également de même pour connaître le nombre d'itérations de votre programme, autrement dit, combien de fois est réalisée votre condition en fonction de la chaîne de caractère renseignée. +

[.text-justify]
Pour ce faire, veuillez à déclarer une variable de type entier au début de votre fonction puis, incrémentez cette valeur *au moment où* l'analyse de votre chaîne de caractère avance également et enfin, veuillez retourner votre résultat pour connaître le nombre de fois où vos conditions ont été exécutée :

[source, c]
----
//Déclarations de variables de test
  int nbIterations = 0;
  
  [...]
  
//Dans les conditions :
  nbIterations++;
  
  [...]
  
//Affichage des tests
  printf("\nNombre d'itérations : %d", nbIterations);
----

==== Analyse
[.text-justify]
Parmi l'ensemble des tests réalisés, le code les passe avec succès sans qu'aucune erreur ne soit à déplorer à la fois sur le résultat attendu mais également sur le code en lui-même.

===== Lisibilité du code
[.text-justify]
En terme de lisibilité de code, bien qu'une javadoc soit absente afin de détailler le fonctionnement de la fonction ``erase``, celui-ci paraît très compréhensible car une distinction nette entre les déclarations de variables, les conditions ainsi que les résultats est présente. +

[.text-justify]
Par ailleurs, les conditions de vérification sont également très claires. Le code est bien décortiqué et compréhensible notamment dans le fait que le développeur ait utilisé une nouvelle chaîne de caractère dépendante de la chaîne de caractère initiale en prenant les modifications à apporter mais également dans l'analyse de la chaîne de caractère en question. Il est clair de voir que les différents *if*, traitent différents cas possibles de la chaîne, tout en veillant à ne pas dépasser la fin de celle-ci, chose gérée dans la bouche *while*.

===== Qualité du code
[.text-justify]
De ce qui peut être constaté, quelques erreurs mineurs sont à constater sur cette solution algorithmique par *Codacy* : +
____
● Une ingérence des chaînes qui ne sont pas terminées par \0 ; si on lui en donne un, il peut effectuer une surlecture (cela pourrait provoquer un plantage s'il n'est pas protégé) ; +
● La condition 'chaine[i]==' '' est _visiblement_ toujours vraie. +
____

D'après *Codacy*, le fichier ``sobriete-57.c`` est noté "B".

image::/rapport/images/sobriete-57.PNG[]

===== Sobriété numérique
[.text-justify]
La mémoire d'un programme C possède une disposition bien particulière puisqu'elle comprend différente sections. 
Pour comprendre davantage la disposition d'une mémoire typique d'un processus en cours d'exécution, veuillez https://www.geeksforgeeks.org/memory-layout-of-c-program/[__cliquer ici__].

Ainsi, pour le calcul de la sobriété numérique, il est nécessaire de voir la consommation utilisée par le fichier compilé (.exe). Ici, elle sera calculée depuis le terminal, en exécutant la commande ``size [file]``. +

Ainsi, la taille du fichier totale (ici en octets) comprend les segments *data*, *text* et *bss*, constituant la mémoire d'un programme C. +
On établira alors une moyenne selon les différentes chaînes de caractères renseignées.

En voici le tableau de cette sobriété numérique :

|===
| *Chaînes de caractères analysées* | *Mémoire consommée* | *Mémoire moyenne consommée*

|``'C'`` 
| 5753 octets
.5+<.>| Environ 5805 octets (selon les chaînes de caractères renseignées)

|``'Cou_cou\__J_M__B'`` 
| 5769 octets

|``'\_Cou_cou\__J_M__B_'`` 
| 5771 octets

|``'Cou_cou\__J_M__B'`` (dupliquée 5x) 
| 5833 octets

|``'Cou_cou\__J_M__B'`` (dupliquée 10x) 
| 5897 octets
|===

===== Efficacité et temps d'exécution
[.text-justify]
Pour alors évaluer l'efficacité et le temps d'exécution de la solution algorithmique, un ensemble de tests est alors réalisé. +
Pour ces tests, j'ai procédé à prendre une chaîne de caractère déjà précédemment utilisée (ici "Cou cou  J M  B") et de voir, en la dupliquant, si le temps d'exécution et le nombre d'itérations varient. +

En voici le tableau adéquat :

|===
| *Chaînes de caractères analysées* | *Résultat de l'algorithme* | *Résultats attendus* | *Temps d'exécution* | *Nombre d'itérations*

|``'C'`` 
|Test passé ✓ 
|``'C'`` 
|0.134s 
|2

|``'Cou_cou\__J_M__B'`` 
|Test passé ✓ 
|``'Coucou\__JM__B'`` 
|1.030s 
|28

|``'\_Cou_cou\__J_M__B_'`` 
|Test passé ✓
|``'Coucou\__JM__B'`` 
|1.299s 
|30

|``'Cou_cou\__J_M__B'`` (dupliquée 5x) 
|Test passé ✓ 
|``'Coucou\__JM__B'`` (dupliquée 5x) 
|1.356s 
|140

|``'Cou_cou\__J_M__B'`` (dupliquée 10x) 
|Test passé ✓ 
|``Coucou\__JM__B`` (dupliquée 10x) 
|1.423s 
|280
|===

[.text-justify]
Nous pouvons ainsi remarquer que le temps d'exécution augmente au fur et à mesure que la chaîne de caractère devient également importante. Pour autant, ce temps d'exécution semble relativement variable et peu corrélé en fonction de la longueur de la chaîne de caractère car, celle-ci l'était également dès lors que l'on exécutait le programme : ce temps d'exécution est évalué par une moyenne, réalisée 5 fois pour car chaîne de caractère analysée.

[.text-justify]
Pour autant, il semblerait que la complexité soit plus facile à calculer en fonction du nombre d'itérations, car le rapprochement semble plus compréhensible et visible. En effet, il est facile de déduire la valeur (ou nombre d'itérations) des caractères utilisés par ce programme : 
____
● 1 pour l'espace simple ; +
● 2 pour un caractère autre que l'espace simple (une lettre par exemple) ; +
● 3 pour un espace s'il est situé entre deux autres espaces. 
____

[.text-justify]
Comme le calcul du nombre d'itérations se fait également selon la longueur de la chaîne de caractère, il semblerait que la complexité du programme ``sobriete-57.c`` soit de l'ordre de O(n + x + y + z) avec n, la longueur de la chaîne de caractère, x un espace simple, y un caractère autre qu'un simple espace, z un espace situé entre deux autres (ou suivi d'un autre).

=== Sobriété n°162 (langage Python)

==== Sous-reproductibilité et références

==== Analyse
[.text-justify]

===== Lisibilité du code
[.text-justify]

===== Qualité du code
[.text-justify]
Visiblement, aucune erreur n'est à constater sur cette solution algorithmique. +
D'après *Codacy*, le fichier ``sobriete-162.py`` est noté "A".

image::/rapport/images/sobriete-162.PNG[]

===== Sobriété numérique
[.text-justify]

===== Efficacité et temps d'exécution
[.text-justify]

=== Sobriété n°166 (langage C)

==== Sous-reproductibilité et références

*Librairie <time.h> :*

[.text-justify]
Pour ainsi évaluer le temps d'exécution que votre algorithme puisse prendre afin d'en déterminer son efficacité, une librairie en langage C permet cette évaluation : la librairie *<time.h>*. +
Pour son importation, veuillez à rajouter la ligne suivante en en-tête du code source :

[source, c]
----
#include <time.h>
----

[.text-justify]
Une fois l'importation de cette librairie, il vous faut l'utiliser. Le programme ici proposé étant réalisé dans un ``main``, nous nous contenterons de rajouter les informations nécessaires dans celui-ci. Pour ce faire, déclarez une variable de type flottant, au début de la fonction ``main`` puis, retournez simplement la valeur prise par votre programme en fin de votre fonction :

[source, c]
----
//Déclarations de variables de test
  float time = 0;
  
  [...]
  
//Affichage des tests :
  time = clock();
  printf("\nTemps d'execution : %.2f ms", time);
  
  return 0; 
----

*Autres :*

[.text-justify]
Enfin, il en va également de même pour connaître le nombre d'itérations de votre programme, autrement dit, combien de fois est réalisée votre condition en fonction de la chaîne de caractère renseignée. +

[.text-justify]
Pour ce faire, veuillez à déclarer une variable de type entier au début de votre ``main`` puis, incrémentez cette valeur *au moment où* l'analyse de votre chaîne de caractère avance également et enfin, veuillez retourner votre résultat pour connaître le nombre de fois où vos conditions ont été exécutée :

[source, c]
----
//Déclarations de variables de test
  int nbIterations = 0;
  
  [...]
  
//Dans les conditions :
  nbIterations++;
  
  [...]
  
//Affichage des tests
  printf("\nNombre d'itérations : %d", nbIterations);
----

[.text-justify]

[.text-justify]

==== Analyse
[.text-justify]
Parmi l'ensemble des tests réalisés, le code les passe avec succès sans qu'aucune erreur ne soit à déplorer sur le code en lui-même. Pour autant, sur le résultat attendu, celui-ci ne respecte pas les attentes souhaitées car il semblerait la chaîne de caractère affichée ne soit uniquement que celle précédée d'un espace.

===== Lisibilité du code
[.text-justify]
Bien que cela figure comme un avis subjectif, cette solution algorithmique n'est pour autant pas très explicite à comprendre. En effet, aucune javadoc n'a été réalisée afin que l'utilisateur réutilisant cette même solution, puisse comprendre la manière employée pour résoudre le problème. +

[.text-justify]
De plus, les conditions de vérification sont également très longues, avec une syntaxe jusque-là peu commune de la part du développeur. +
Celle-ci prend la forme suivante : ``[...] ? [...] : [...]``. +

[.text-justify]
Enfin, l'utilisation d'un tableau à double entrée n'est pas nécessairement très instructif, d'autant plus dans son utilisation ici-même. +
Concrètement, la chaîne de caractère sera toujours la même lors de l'analyse, bien que celle-ci se réalise étape par étape sur les caractères constituant cette même chaîne de caractère. Il est alors inutile de renseigner constamment comme premier élément, la même chaîne de caractère.

===== Qualité du code
[.text-justify]
Visiblement, aucune erreur n'est à constater sur cette solution algorithmique. +
D'après *Codacy*, le fichier ``sobriete-166.c`` est noté "A".

image::/rapport/images/sobriete-166.PNG[]

===== Sobriété numérique
[.text-justify]
La mémoire d'un programme C possède une disposition bien particulière puisqu'elle comprend différente sections. 
Pour comprendre davantage la disposition d'une mémoire typique d'un processus en cours d'exécution, veuillez https://www.geeksforgeeks.org/memory-layout-of-c-program/[__cliquer ici__].

Ainsi, pour le calcul de la sobriété numérique, il est nécessaire de voir la consommation utilisée par le fichier compilé (.exe). Ici, elle sera calculée depuis le terminal, en exécutant la commande ``size [file]``. +

Ainsi, la taille du fichier totale (ici en octets) comprend les segments *data*, *text* et *bss*, constituant la mémoire d'un programme C. +
On établira alors une moyenne selon les différentes chaînes de caractères renseignées.

En voici le tableau de cette sobriété numérique :

|===
| *Chaînes de caractères analysées* | *Mémoire consommée* | *Mémoire moyenne consommée*

|``'C'`` 
| 5897 octets
.5+<.>| 5897 octets

|``'Cou_cou\__J_M__B'`` 
| 5897 octets

|``'\_Cou_cou\__J_M__B_'`` 
| 5897 octets

|``'Cou_cou\__J_M__B'`` (dupliquée 5x) 
| 5897 octets

|``'Cou_cou\__J_M__B'`` (dupliquée 10x) 
| 5897 octets
|===

[.text-justify]
Le programme étant regroupé dans un main, il est difficile d'évaluer la mémoire d'un processus en cours d'exécution, d'autant plus quand le test de la chaîne de caractère ne peut que se faire depuis le terminal (après compilation du programme C en un fichier compilé .exe, puis exécution de celui-ci en renseignant la chaîne de caractère souhaitée). 

===== Efficacité et temps d'exécution
[.text-justify]
Pour alors évaluer l'efficacité et le temps d'exécution de la solution algorithmique, un ensemble de tests est alors réalisé. +
Pour ces tests, j'ai procédé à prendre une chaîne de caractère déjà précédemment utilisée (ici "Cou cou  J M  B") et de voir, en la dupliquant, si le temps d'exécution et le nombre d'itérations varient. +

En voici le tableau adéquat :

|===
| *Chaînes de caractères analysées* | *Résultat de l'algorithme* | *Résultats attendus* | *Temps d'exécution* | *Nombre d'itérations*

|``'C'`` 
|Test passé ✓ 
|``'C'`` 
|15.00ms 
|1

|``'Cou_cou\__J_M__B'`` 
|Test invalide ✘ 
|``'Coucou\__JM__B'`` 
|30.00ms 
|3

|``'\_Cou_cou\__J_M__B_'`` 
|Test invalide ✘ 
|``'Coucou\__JM__B'`` 
|30.00ms 
|3

|``'Cou_cou\__J_M__B'`` (dupliquée 5x) 
|Test invalide ✘ 
|``'Coucou\__JM__B'`` (dupliquée 5x) 
|30.00ms 
|3

|``'Cou_cou\__J_M__B'`` (dupliquée 10x) 
|Test invalide ✘ 
|``Coucou\__JM__B`` (dupliquée 10x) 
|30.00ms 
|3
|===

[.text-justify]
Ainsi, dès lors que la chaîne de caractère est dupliquée, le temps ainsi que le nombre d'itérations reste le même et pour cause : l'algorithme ne fonctionne pas lorsque l'on met un ou plusieurs espaces dans la chaîne de caractère. +
Dès lors qu'une chaîne de caractère est située au début, l'algorithme ne semble visiblement pas traiter le cas, passant directement au premier morceau de cette chaîne.

[.text-justify]
Autrement dit, il prendra seulement en considération le début de la chaîne de caractère non séparée du reste de celle-ci par un espace. De ce fait, traitant alors constamment la même chaîne de caractère, la complexité du programme ``sobriete-166.c`` semble se rapprocher de *O(1)*, bien que celle-ci soit complètement faussée car le résultat attendu ne correspond pas à la demande souhaitée.

== Catégorie "Efficacité"

=== Efficacité n°43 (langage Java)

==== Sous-reproductibilité et références

==== Analyse
[.text-justify]

===== Lisibilité du code
[.text-justify]

===== Qualité du code
[.text-justify]
De ce qui peut être constaté, seul une erreur mineure est à déclarer d'après *Codacy* :
____
● Le nom de la classe utilitaire 'Eraser2' ne correspond pas à '[AZ][a-zA-Z0-9]'. +
Autrement dit, cette règle signale les déclarations de type qui ne correspondent pas à la regex qui s'applique à leur genre spécifique.
____

[.text-justify]
De ce fait, bien que cela soit une erreur mineure, le fichier ``efficacite-43.java`` est noté "B" d'après *Codacy*.

image::/rapport/images/efficacite-43.PNG[]

===== Sobriété numérique
[.text-justify]

===== Efficacité et temps d'exécution
[.text-justify]

=== Efficacité n°90 (langage Java)

==== Sous-reproductibilité et références

==== Analyse
[.text-justify]

===== Lisibilité du code
[.text-justify]

===== Qualité du code
[.text-justify]
A comparer du fichier précédemment analysé (``efficacite-43.java``), celui-ci possède également la même erreur mineure de code à savoir :
____
● Le nom de la classe utilitaire 'Eraser' ne correspond pas à '[AZ][a-zA-Z0-9]'. +
Autrement dit, cette règle signale les déclarations de type qui ne correspondent pas à la regex qui s'applique à leur genre spécifique.
____

[.text-justify]
En réalité, bien que le fichier ``efficacite-90.java`` diffère du fait de sa notation par *Codacy* à savoir la notation de "C", cela est en grande partie dû à la complexité mais celle-ci n'est pas une complexité similaire de celle que l'on pourrait calculer comme la complexité temporelle : il s'agit d'une complexité cyclomatique. +
Concrètement, moins il y a de chemins à travers un morceau de code et moins ces chemins sont complexes, plus la complexité cyclomatique est faible. Ces chemins peuvent concerner des déclarations de variables, des sous-conditions, etc. Ici, sa complexité est 2x plus élevée, d'où sa notation plus mauvaise. 

image::/rapport/images/efficacite-90.PNG[]

===== Sobriété numérique
[.text-justify]

===== Efficacité et temps d'exécution
[.text-justify]

=== Efficacité n°106 (langage Python)

==== Sous-reproductibilité et références

===== Lisibilité du code
[.text-justify]

===== Qualité du code
[.text-justify]
*Codacy* remarque ici-même la présence de quelques erreurs mineures. Les voici :
____
● Espace blanc de fin (ligne vide) ; +
● Préférence à l'utilisation de '== / !=' pour comparer des littéraux constants (str, bytes, int, float, tuple).
____

[.text-justify]
En réalité, il est véridique de dire qu'il soit nécesasire d'ajuster certains points de ce code, pouvant le rendre plus qualitatif et respectueux des différentes règles interposées par *Codacy*. Pour autant, le fichier ``efficacite-106.py`` est noté "C".

image::/rapport/images/efficacite-106.PNG[]

===== Sobriété numérique
[.text-justify]

===== Efficacité et temps d'exécution
[.text-justify]

=== Efficacité n°131 (langage Java)

==== Sous-reproductibilité et références

==== Analyse
[.text-justify]

===== Lisibilité du code
[.text-justify]

===== Qualité du code
[.text-justify]
Le fichier ``efficacite-131.java`` est *le* fichier le plus mauvais en terme de qualité d'après *Codacy*. Bien qu'une erreur mineure soit alors à constater (et déjà présente dans certains des fichiers précédemment analysés), deux erreurs moyennes sont tout de même à déplorer. Les voici :

*Erreur mineure :*
____
● Le nom de la classe utilitaire 'Eraser' ne correspond pas à '[AZ][a-zA-Z0-9]'. +
Autrement dit, cette règle signale les déclarations de type qui ne correspondent pas à la regex qui s'applique à leur genre spécifique.
____

*Erreurs moyennes :*
____
● Préférence d'éviter les variables locales inutilisées telles que 'i' ; +
● Le fait d'éviter de réaffecter des paramètres tels que 'str'.
____

Sans contestation possible, le fichier ``efficacite-131.java`` est non-seulement le pire en terme de qualité, mais il est également noté "F" par *Codacy*, chose plutôt compréhensible.

image::/rapport/images/efficacite-131.PNG[]

===== Sobriété numérique
[.text-justify]

===== Efficacité et temps d'exécution
[.text-justify]

== Catégorie "Simplicité"

=== Simplicité n°11 (langage Java)

==== Sous-reproductibilité et références

==== Analyse
[.text-justify]

===== Lisibilité du code
[.text-justify]

===== Qualité du code
[.text-justify]
De ce qui peut être constaté, quelques erreurs mineurs ainsi qu'une erreur moyenne sont à constater sur cette solution algorithmique par *Codacy* : +

*Erreurs mineures :*
____
● Le nom de la classe utilitaire 'Erase1' ne correspond pas à '[AZ][a-zA-Z0-9]' ; +
Concrètement, comme déjà mentionné auparavant, il s'agit d'un non-respect de convention de dénomination configurables pour les déclarations de type. Elle signale les déclarations de type qui ne correspondent pas à la regex qui s'applique à leur genre spécifique ; +
● Toutes les classes, interfaces, énumérations et annotations doivent appartenir à un package nommé, chose ici non-présente. +
____

*Erreur moyenne :*
____
● La méthode 'erase1(String)' a une complexité NPath (nombre de chemins acycliques) de 384, le seuil actuel est de 200. +
Cette complexité NPath correspond au nombre de chemins d'exécution acycliques à travers cette méthode, étant alors des chemins complets du début à la fin du bloc de la méthode. Ainsi, cette métrique croît de manière exponentielle, car elle multiplie la complexité des instructions dans le même bloc. +
Le seuil recommandé par Codacy est de 200 car il est considéré comme étant le point où des mesures doivent être prises pour réduire la complexité et augmenter la lisibilité.
____

Ainsi, bien que le code reste pour autant assez qualitatif, *Codacy* note le fichier ``simplicite-11.java`` "B".

image::/rapport/images/simplicite-11.PNG[]

===== Sobriété numérique
[.text-justify]

===== Efficacité et temps d'exécution
[.text-justify]

=== Simplicité n°39 (langage Java)

==== Sous-reproductibilité et références

==== Analyse
[.text-justify]

===== Lisibilité du code
[.text-justify]

===== Qualité du code
[.text-justify]
Il semblerait qu'aucune erreur ne soit à constater sur cette solution algorithmique. Il paraît alors être le plus qualitatif des autres. +
D'après *Codacy*, le fichier ``simplicite-39.java`` est noté "A".

image::/rapport/images/simplicite-39.PNG[]

===== Sobriété numérique
[.text-justify]

===== Efficacité et temps d'exécution
[.text-justify]

=== Simplicité n°56 (langage Java)

==== Sous-reproductibilité et références

==== Analyse
[.text-justify]

===== Lisibilité du code
[.text-justify]

===== Qualité du code
[.text-justify]
A en suivre l'analyse réalisée par *Codacy*, il semblerait que quelques erreurs soient à constater, aussi bien mineures que moyennes. Les voici :

*Erreur mineure :*
____
● Le nom de la classe utilitaire 'Eraser' ne correspond pas à '[AZ][a-zA-Z0-9]'. +
Cette erreur paraît commune à beaucoup de code à analyser. Il s'agit, comme déjà mentionné, d'un non-respect de convention de dénomination configurables pour les déclarations de type. Elle signale les déclarations de type qui ne correspondent pas à la regex qui s'applique à leur genre spécifique ; +
____

*Erreur moyenne :*
____
● Des instructions if sont imbriquées et pourraient être combinées.
____

Il semble alors que le code présente de la redondance dans certaines conditions, que l'on pourrait condenser et donc, simplifier. De ce fait, l'algorithme serait plus qualitatif et ne présenterait aucune condition de trop, ou supplémentaire que l'on peut alors ajuster.

Néanmoins, d'après *Codacy*, le fichier ``simplicite-56.java`` est noté "B".

image::/rapport/images/simplicite-56.PNG[]

==== Sous-reproductibilité et références

===== Lisibilité du code
[.text-justify]

===== Qualité du code
[.text-justify]
Enfin, pour ce dernier fichier à analyser, *Codacy* montre une nouvelle fois, la même erreur mineure que déjà constatée auparavant :
____
● Le nom de la classe utilitaire 'Eraser' ne correspond pas à '[AZ][a-zA-Z0-9]'. +
Il s'agit d'un non-respect de convention de dénomination configurables pour les déclarations de type. Elle signale les déclarations de type qui ne correspondent pas à la regex qui s'applique à leur genre spécifique. +
____

Bien que ce soit la seule soi-disante "erreur" à constater, *Codacy* a attribué la note de "B" au fichier ``simplicite-71.java``.

image::/rapport/images/simplicite-71.PNG[]

===== Sobriété numérique
[.text-justify]

===== Efficacité et temps d'exécution
[.text-justify]

== Classement

Voici donc le classement final selon les catégories :

|===
|Catégorie |Solution algorithmique |Position |Notation

.4+<.>|Simplicité
|``simplicite-11.java``
|
|

|``simplicite-39.java``
|
|

|``simplicite-56.java``
|
|

|``simplicite-71.java``
|
|


.4+<.>|Efficacité
|``efficacite-43.java``
|
|

|``efficacite-90.java``
|
|

|``efficacite-106.py``
|
|

|``efficacite-131.java``
|
|

.3+<.>|Sobriété
|``sobriete-57.c``
|
|

|``sobriete-162.py``
|
|

|``sobriete-166.c``
|
|
|===

== Exemple de code

=== Efficacité n°21 (python)

==== Prérequis
[.text-justify]
Ajouter le code suivant tout en haut du fichier ``test.py`` : +

[source, python]
----
import sys
sys.path.append('analyse/solutions/') # import python files from path 'analyse/solutions'
from efficacite21 import erase
----

[.text-justify]
Il permet de vérifier que le programme traite bien tous les cas donnés. +
 +

[.text-justify]
Le fichier ``analyse.py`` du répertoire ``analyse`` permet d'obtenir les temps d'exécutions du programme en fonction de chaînes générées aléatoirement de tailles données.


==== Reproductibilité
[.text-justify]
Lancer le code de ``test.py``, le programme devrait s'exécuter même si une erreur de compilation est relevée dans la close donnée dans les prérequis. Vérifier que le programme traite de tous les cas donnés.

[.text-justify]
Lancer le code de ``analyse.py``, le programme devrait s'exécuter même si une erreur de compilation est relevée dans la close donnée dans les prérequis. Analyser les temps d'exécutions en fonction des différentes tailles de chaînes.

==== Analyse
[.text-justify]
[red]#Ce code ne passe pas tous les tests !#

===== Lisibilité du code
[.text-justify]

===== Qualité du code
[.text-justify]

===== Sobriété numérique
[.text-justify]

===== Efficacité et temps d'exécution
[.text-justify]
Les temps d'exécutions analysés via le programme ``analyse.py`` semblent être inconstants. La complexité du programme ``efficacite21`` dépend du nombre d'espace dans la chaîne donnée. Cette dernière semble se rapprocher le plus de *O(2n)*.
